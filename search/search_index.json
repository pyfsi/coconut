{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoCoNuT installation For users Requirements: Python 3.6+ Installation: Download the source code from GitHub Unzip to a folder coconut . Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to you .bashrc file. For developers Requirements: Python 3.6+ Git Installation: Choose or create a directory to install CoCoNuT. Copy the code below to a bash-script and adapt the parameter absolute_path to the above directory. Run bash-script. #!/bin/bash # add absolute path to parent directory of coconut absolute_path = /some/absolute/path # configure repository cd $absolute_path git clone git@github.com:pyfsi/coconut.git cd coconut git remote add upstream git@github.com:pyfsi/coconut.git # add coconut to Python path --> put this line also in your .bashrc export PYTHONPATH = $absolute_path : $PYTHONPATH # run tests cd $absolute_path /coconut/tests python test_coconut.py # run an FSI test example cd $absolute_path /coconut/test_examples/tube_tube_flow_tube_structure chmod 700 setup_tube_flow.sh setup_tube_structure.sh ./setup_tube_flow.sh ./setup_tube_structure.sh python MainKratos.py project_parameters_mapped.json # > $absolute_path/tube.log","title":"CoCoNuT installation"},{"location":"#coconut-installation","text":"","title":"CoCoNuT installation"},{"location":"#for-users","text":"Requirements: Python 3.6+ Installation: Download the source code from GitHub Unzip to a folder coconut . Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to you .bashrc file.","title":"For users"},{"location":"#for-developers","text":"Requirements: Python 3.6+ Git Installation: Choose or create a directory to install CoCoNuT. Copy the code below to a bash-script and adapt the parameter absolute_path to the above directory. Run bash-script. #!/bin/bash # add absolute path to parent directory of coconut absolute_path = /some/absolute/path # configure repository cd $absolute_path git clone git@github.com:pyfsi/coconut.git cd coconut git remote add upstream git@github.com:pyfsi/coconut.git # add coconut to Python path --> put this line also in your .bashrc export PYTHONPATH = $absolute_path : $PYTHONPATH # run tests cd $absolute_path /coconut/tests python test_coconut.py # run an FSI test example cd $absolute_path /coconut/test_examples/tube_tube_flow_tube_structure chmod 700 setup_tube_flow.sh setup_tube_structure.sh ./setup_tube_flow.sh ./setup_tube_structure.sh python MainKratos.py project_parameters_mapped.json # > $absolute_path/tube.log","title":"For developers"},{"location":"abaqus/","text":"SolverWrapperAbaqus This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible. Terminology Main directory : Directory where the Python code will be executed Source directory (for wrapper): Kratos/applications/CoSimulationApplication/python_scripts/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied. Environment A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. Abaqus needs an AbaqusHosts.txt file in the working directory. This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory The extra directory contains a file abaqus_setup which should be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers. Parameters This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters. Mandatory parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher CoSimulationObject. dimensions integer Dimensionality of the problem (2 or 3) interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this modelpart. (Note the comma) Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus load points. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (See the Input file section) \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from [data should be available at this time step. For a new simulation this value will typically be 0] (Should be synchronized with the flow solver). This parameter is usually specified in a higher CoSimulationObject. working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section. Optional parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep ramp integer Only important when subcycling is enabled in Abaqus. 0 : Load is considered to be constant throughout the time step 1 : [Default] Load is applied in a ramped fashion throughout the time step subcycling integer 0 : [Default] Abaqus solves the requested time step using one increment 1 : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved Input file The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file. General The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: - Geometry - Mesh - Material properties - Boundary conditions - Surfaces where external loads need to be applied - Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Setup for Abaqus input (loads) Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly. These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the \u201cSurfaceFromNodeSet\u201d function which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer. The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): ```my_model=mdb.models['Model-1']* my_assembly=my_model.rootAssembly my_instance=my_assembly.instances['PART-1-1'] movingSurface0 = SurfaceFromNodeSet(my_model, my_instance, 'NAME_OF_THE_NODESET', 'MOVINGSURFACE0') On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model.ImplicitDynamicsStep(name='Step-1', previous='Initial', timePeriod=1, nlgeom=ON, maxNumInc=1, haftol=1, initialInc=1, minInc=1, maxInc=1, amplitude=RAMP, noStop=OFF, nohaf=ON, initialConditions=OFF, timeIncrementationMethod=FIXED, application=QUASI_STATIC) my_model.Pressure(name = 'DistributedPressure', createStepName = 'Step-1', distributionType = USER_DEFINED, field = '', magnitude = 1, region=movingSurface0) my_model.SurfaceTraction(name = 'DistributedShear', createStepName = 'Step-1', region = movingSurface0, magnitude = 1, traction = GENERAL, directionVector = ((0,0,0), (1,0,0)), distributionType = USER_DEFINED) ### Setup for Abaqus output (displacements) After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated for each surface involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this hadn\u2019t been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. Furthermore, it is interesting to output maintain the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-1', region=tubeAssembly.sets['NAME_OF_THE_NODE_SET'], variables=('COORD', 'U')) my_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-2', variables=PRESELECT) my_model.HistoryOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='H-Output-1', variables=PRESELECT) ```","title":"SolverWrapperAbaqus"},{"location":"abaqus/#solverwrapperabaqus","text":"This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible.","title":"SolverWrapperAbaqus"},{"location":"abaqus/#terminology","text":"Main directory : Directory where the Python code will be executed Source directory (for wrapper): Kratos/applications/CoSimulationApplication/python_scripts/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied.","title":"Terminology"},{"location":"abaqus/#environment","text":"A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. Abaqus needs an AbaqusHosts.txt file in the working directory. This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory The extra directory contains a file abaqus_setup which should be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers.","title":"Environment"},{"location":"abaqus/#parameters","text":"This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters.","title":"Parameters"},{"location":"abaqus/#mandatory","text":"parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher CoSimulationObject. dimensions integer Dimensionality of the problem (2 or 3) interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this modelpart. (Note the comma) Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus load points. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (See the Input file section) \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from [data should be available at this time step. For a new simulation this value will typically be 0] (Should be synchronized with the flow solver). This parameter is usually specified in a higher CoSimulationObject. working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section.","title":"Mandatory"},{"location":"abaqus/#optional","text":"parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep ramp integer Only important when subcycling is enabled in Abaqus. 0 : Load is considered to be constant throughout the time step 1 : [Default] Load is applied in a ramped fashion throughout the time step subcycling integer 0 : [Default] Abaqus solves the requested time step using one increment 1 : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved","title":"Optional"},{"location":"abaqus/#input-file","text":"The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file.","title":"Input file"},{"location":"abaqus/#general","text":"The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: - Geometry - Mesh - Material properties - Boundary conditions - Surfaces where external loads need to be applied - Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software.","title":"General"},{"location":"abaqus/#setup-for-abaqus-input-loads","text":"Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly. These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the \u201cSurfaceFromNodeSet\u201d function which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer. The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): ```my_model=mdb.models['Model-1']* my_assembly=my_model.rootAssembly my_instance=my_assembly.instances['PART-1-1'] movingSurface0 = SurfaceFromNodeSet(my_model, my_instance, 'NAME_OF_THE_NODESET', 'MOVINGSURFACE0') On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model.ImplicitDynamicsStep(name='Step-1', previous='Initial', timePeriod=1, nlgeom=ON, maxNumInc=1, haftol=1, initialInc=1, minInc=1, maxInc=1, amplitude=RAMP, noStop=OFF, nohaf=ON, initialConditions=OFF, timeIncrementationMethod=FIXED, application=QUASI_STATIC) my_model.Pressure(name = 'DistributedPressure', createStepName = 'Step-1', distributionType = USER_DEFINED, field = '', magnitude = 1, region=movingSurface0) my_model.SurfaceTraction(name = 'DistributedShear', createStepName = 'Step-1', region = movingSurface0, magnitude = 1, traction = GENERAL, directionVector = ((0,0,0), (1,0,0)), distributionType = USER_DEFINED) ### Setup for Abaqus output (displacements) After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated for each surface involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this hadn\u2019t been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. Furthermore, it is interesting to output maintain the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-1', region=tubeAssembly.sets['NAME_OF_THE_NODE_SET'], variables=('COORD', 'U')) my_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-2', variables=PRESELECT) my_model.HistoryOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='H-Output-1', variables=PRESELECT) ```","title":"Setup for Abaqus input (loads)"},{"location":"docs/","text":"Guide to the documentation This website is a collection of all MarkDown (MD) files found in the CoSimulationApplication folder and its subfolders. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file. Documentation in MarkDown MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link. A note on math in MD. There is no out-of-the-box LaTeX compatibiliy sadly, but basic equations can be typeset directly in HTML if necessary. Some usefull symbols: lowercase Greek: \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03d1\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03d5\u03c7\u03c8\u03c9 uppercase Greek: \u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9 super and subscripts: <sup></sup> and <sub></sub> operators: + - \u2212 \u00b7 / \u00d7 \u221a \u2218 \u2217 other symbols: \u2202 \u0394 \u2211 \u2264 \u2265 \u2208 more math symbols It is also possible to render LaTeX equations on-the-run and importing them as images, but that is quite cumbersome. TODO: add paragraph about MathJax? some inline math \\alpha + \\beta = a^{k+1}_0 \\alpha + \\beta = a^{k+1}_0 some other math: \\alpha + \\beta = a^{k+1}_0 \\alpha + \\beta = a^{k+1}_0 Creating a static website with MkDocs MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material Both can be installed locally by adding the argument -t <install_dir> . The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in the CoSimulationApplication folder and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . Deploy website on GitHub Pages using mkdocs gh-deploy . To activate the website, the user must have administrator privileges in the repository.","title":"Guide to the documentation"},{"location":"docs/#guide-to-the-documentation","text":"This website is a collection of all MarkDown (MD) files found in the CoSimulationApplication folder and its subfolders. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file.","title":"Guide to the documentation"},{"location":"docs/#documentation-in-markdown","text":"MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link. A note on math in MD. There is no out-of-the-box LaTeX compatibiliy sadly, but basic equations can be typeset directly in HTML if necessary. Some usefull symbols: lowercase Greek: \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03d1\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03d5\u03c7\u03c8\u03c9 uppercase Greek: \u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9 super and subscripts: <sup></sup> and <sub></sub> operators: + - \u2212 \u00b7 / \u00d7 \u221a \u2218 \u2217 other symbols: \u2202 \u0394 \u2211 \u2264 \u2265 \u2208 more math symbols It is also possible to render LaTeX equations on-the-run and importing them as images, but that is quite cumbersome. TODO: add paragraph about MathJax? some inline math \\alpha + \\beta = a^{k+1}_0 \\alpha + \\beta = a^{k+1}_0 some other math: \\alpha + \\beta = a^{k+1}_0 \\alpha + \\beta = a^{k+1}_0","title":"Documentation in MarkDown"},{"location":"docs/#creating-a-static-website-with-mkdocs","text":"MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material Both can be installed locally by adding the argument -t <install_dir> . The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in the CoSimulationApplication folder and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . Deploy website on GitHub Pages using mkdocs gh-deploy . To activate the website, the user must have administrator privileges in the repository.","title":"Creating a static website with MkDocs"},{"location":"fluent/","text":"SolverWrapperFluent This is the documentation for all Fluent SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet. Parameters This section describes the Parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher CoSimulationObject. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and '_nodes'. The values are (lists of) names of Variables. interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int The parameter is used to construct unique IDs for faces, based on unique IDs of nodes. It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher CoSimulationObject. unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1): - X.py: defines the SolverWrapperFluentX class - X.jou: Fluent journal file to interactively run the FSI simulation, written in Scheme - X.c: Fluent UDF file that implements additional functionality used in Fluent, written in C The __init__ method During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to thread IDs, for use in the UDFs. Then the Model and ModelPart objects are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Node objects are updated to the current values. Finally, the CoSimulationInteface objects are made. Files created during simulation In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal). Setting up a new case Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then default should be set for standard initialization Following items are done after starting the FSI simulation, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization Version specific documentation 2019R1 (19.3) This is currently the only version, so this section is still empty.","title":"SolverWrapperFluent"},{"location":"fluent/#solverwrapperfluent","text":"This is the documentation for all Fluent SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet.","title":"SolverWrapperFluent"},{"location":"fluent/#parameters","text":"This section describes the Parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher CoSimulationObject. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and '_nodes'. The values are (lists of) names of Variables. interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int The parameter is used to construct unique IDs for faces, based on unique IDs of nodes. It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher CoSimulationObject. unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"fluent/#overview-of-operation","text":"The solver wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1): - X.py: defines the SolverWrapperFluentX class - X.jou: Fluent journal file to interactively run the FSI simulation, written in Scheme - X.c: Fluent UDF file that implements additional functionality used in Fluent, written in C","title":"Overview of operation"},{"location":"fluent/#the-__init__-method","text":"During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to thread IDs, for use in the UDFs. Then the Model and ModelPart objects are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Node objects are updated to the current values. Finally, the CoSimulationInteface objects are made.","title":"The __init__ method"},{"location":"fluent/#files-created-during-simulation","text":"In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal).","title":"Files created during simulation"},{"location":"fluent/#setting-up-a-new-case","text":"Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then default should be set for standard initialization Following items are done after starting the FSI simulation, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization","title":"Setting up a new case"},{"location":"fluent/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"fluent/#2019r1-193","text":"This is currently the only version, so this section is still empty.","title":"2019R1 (19.3)"},{"location":"mappers/","text":"Mappers General concepts Hierarchy of mapping-related objects CoCoNuT interacts with the mappers through the SolverWrapperMapped object: this wrapper behaves like every other SolverWrapper as far as the other components are concerned. It contains 3 main components: a Mapper for the input, a real SolverWrapper and a Mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the CoSimulationInterface objects that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped object are also of a special type: they work on the level of CoSimulationInterface objects. They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelPart objects, based on the coordinates of the nodes. Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined object, creating in fact another layer of mapping. So many layers! Like an onion! Interpolators and transformers The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelPart objects. There are two types of ModelPart -level mappers: interpolators and transformers. They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. Overview of special mappers MapperInterface Special mapper-class that maps on the level of CoSimulationInterface objects. It takes two CoSimulationInterface objects, and maps the ModelPart objects to each other in order of appearance, all using the same ModelPart mapper. To use different interpolation for the different ModelPart objects or even for different historical variables, a new CoSimulationInterface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type MapperCombined The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelPart objects are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used Overview of transformers MapperPermutation Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2] MapperAxisymmetric2DTo3D Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in a MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential ones are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D ones. For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6 MapperAxisymmetric3DTo2D Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in a MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar. Overview of interpolators MapperInterpolator Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize -method should be called in all child-classes. It does the following: - read and store the coordinates from the from and to ModelPart objects - check if the bounding boxes of the from and to ModelPart objects are more or less overlapping - do an efficient nearest neighbour search using scipy.spatial.cKDTree - check if the from ModelPart does not contain duplicate nodes (i.e. same coordinates) The __call__ -method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component). MapperNearest Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping. MapperLinear Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed. MapperRadialBasis Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \u03c6 ( r ) \\phi(r) \\phi(r) is a radial basis function defined as \u03c6 ( r ) = (1 \u2212 r ) 4 (1 + 4 r ) for 0 \u2264 r < 1 \u03c6 ( r ) = 0 for 1 \u2264 r \\phi(r) = (1-r)^4 (1 + 4r) \\mathrm{for} 0 \\leq r < 1 \\phi(r) = (1-r)^4 (1 + 4r) \\mathrm{for} 0 \\leq r < 1 \\phi(r) = 0 \\mathrm{for} 1 \\leq r \\phi(r) = 0 \\mathrm{for} 1 \\leq r with r a positive distance. Assume that n nearest from -points will be used in the interpolation. An unknown function f ( x ) can then be approximated as the weighted sum of n shifted radial basis functions: f ( x ) \u2248 \u03a3 j \u03b1 j \u03c6 (|| x \u2212 x j ||) To determine the coefficients \u03b1 j , we require that the exact function value is returned at the n from -points. This gives us n equations f ( x i ) = f i = \u03a3 j \u03b1 j \u03c6 (|| x i \u2212 x j ||) which can be written in matrix form as f = \u03a6 \u00b7 \u03b1 with f , \u03b1 \u2208 R n\u00d71 , and \u03a6 \u2208 R n\u00d7n . This system can be solved for the weights-vector \u03b1 . However, in our case, the from -point values vector f is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f ( x to ) = \u03a3 j \u03b1 j \u03c6 (|| x to \u2212 x j ||) = \u03a6 T to \u00b7 \u03b1 = \u03a6 T to \u00b7 \u03a6 -1 \u00b7 f = c T \u00b7 f The coefficients vector c can now be calculated based only on the coordinates by solving the system \u03a6 \u00b7 c = \u03a6 to . As every to-point has different nearest neighbours in the from -points, the coefficient vector c must be calculated for each to -point independently. The matrix \u03a6 and vector \u03a6 T must also be calculated for every to -point independently.","title":"Mappers"},{"location":"mappers/#mappers","text":"","title":"Mappers"},{"location":"mappers/#general-concepts","text":"","title":"General concepts"},{"location":"mappers/#hierarchy-of-mapping-related-objects","text":"CoCoNuT interacts with the mappers through the SolverWrapperMapped object: this wrapper behaves like every other SolverWrapper as far as the other components are concerned. It contains 3 main components: a Mapper for the input, a real SolverWrapper and a Mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the CoSimulationInterface objects that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped object are also of a special type: they work on the level of CoSimulationInterface objects. They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelPart objects, based on the coordinates of the nodes. Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined object, creating in fact another layer of mapping. So many layers! Like an onion!","title":"Hierarchy of mapping-related objects"},{"location":"mappers/#interpolators-and-transformers","text":"The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelPart objects. There are two types of ModelPart -level mappers: interpolators and transformers. They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator.","title":"Interpolators and transformers"},{"location":"mappers/#overview-of-special-mappers","text":"","title":"Overview of special mappers"},{"location":"mappers/#mapperinterface","text":"Special mapper-class that maps on the level of CoSimulationInterface objects. It takes two CoSimulationInterface objects, and maps the ModelPart objects to each other in order of appearance, all using the same ModelPart mapper. To use different interpolation for the different ModelPart objects or even for different historical variables, a new CoSimulationInterface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type","title":"MapperInterface"},{"location":"mappers/#mappercombined","text":"The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelPart objects are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used","title":"MapperCombined"},{"location":"mappers/#overview-of-transformers","text":"","title":"Overview of transformers"},{"location":"mappers/#mapperpermutation","text":"Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2]","title":"MapperPermutation"},{"location":"mappers/#mapperaxisymmetric2dto3d","text":"Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in a MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential ones are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D ones. For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6","title":"MapperAxisymmetric2DTo3D"},{"location":"mappers/#mapperaxisymmetric3dto2d","text":"Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in a MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar.","title":"MapperAxisymmetric3DTo2D"},{"location":"mappers/#overview-of-interpolators","text":"","title":"Overview of interpolators"},{"location":"mappers/#mapperinterpolator","text":"Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize -method should be called in all child-classes. It does the following: - read and store the coordinates from the from and to ModelPart objects - check if the bounding boxes of the from and to ModelPart objects are more or less overlapping - do an efficient nearest neighbour search using scipy.spatial.cKDTree - check if the from ModelPart does not contain duplicate nodes (i.e. same coordinates) The __call__ -method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component).","title":"MapperInterpolator"},{"location":"mappers/#mappernearest","text":"Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping.","title":"MapperNearest"},{"location":"mappers/#mapperlinear","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.","title":"MapperLinear"},{"location":"mappers/#mapperradialbasis","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \u03c6 ( r ) \\phi(r) \\phi(r) is a radial basis function defined as \u03c6 ( r ) = (1 \u2212 r ) 4 (1 + 4 r ) for 0 \u2264 r < 1 \u03c6 ( r ) = 0 for 1 \u2264 r \\phi(r) = (1-r)^4 (1 + 4r) \\mathrm{for} 0 \\leq r < 1 \\phi(r) = (1-r)^4 (1 + 4r) \\mathrm{for} 0 \\leq r < 1 \\phi(r) = 0 \\mathrm{for} 1 \\leq r \\phi(r) = 0 \\mathrm{for} 1 \\leq r with r a positive distance. Assume that n nearest from -points will be used in the interpolation. An unknown function f ( x ) can then be approximated as the weighted sum of n shifted radial basis functions: f ( x ) \u2248 \u03a3 j \u03b1 j \u03c6 (|| x \u2212 x j ||) To determine the coefficients \u03b1 j , we require that the exact function value is returned at the n from -points. This gives us n equations f ( x i ) = f i = \u03a3 j \u03b1 j \u03c6 (|| x i \u2212 x j ||) which can be written in matrix form as f = \u03a6 \u00b7 \u03b1 with f , \u03b1 \u2208 R n\u00d71 , and \u03a6 \u2208 R n\u00d7n . This system can be solved for the weights-vector \u03b1 . However, in our case, the from -point values vector f is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f ( x to ) = \u03a3 j \u03b1 j \u03c6 (|| x to \u2212 x j ||) = \u03a6 T to \u00b7 \u03b1 = \u03a6 T to \u00b7 \u03a6 -1 \u00b7 f = c T \u00b7 f The coefficients vector c can now be calculated based only on the coordinates by solving the system \u03a6 \u00b7 c = \u03a6 to . As every to-point has different nearest neighbours in the from -points, the coefficient vector c must be calculated for each to -point independently. The matrix \u03a6 and vector \u03a6 T must also be calculated for every to -point independently.","title":"MapperRadialBasis"},{"location":"pykratos/","text":"CoSimulation Application PYTHON ONLY VERSION This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests","title":"Pykratos"},{"location":"pykratos/#cosimulation-application-python-only-version","text":"This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests","title":"CoSimulation Application PYTHON ONLY VERSION"},{"location":"python_solvers/","text":"Pure Python SolverWrappers (empty documentation)","title":"Pure Python SolverWrappers"},{"location":"python_solvers/#pure-python-solverwrappers","text":"(empty documentation)","title":"Pure Python SolverWrappers"},{"location":"test_examples/","text":"Test Examples This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube. Folder and file structure This section describes the different folders and files which are provided. MainKratos.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X readme.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run. Running a case In order to run a test example, the case have to be made ready by running the setup files for both solvers. Then, the calculation is started by running MainKratos.py with the parameter file as argument. Debug files The folder test_examples also contains a folder debug_files with files for debug purposes. In order to use those, the debug boolean self.debug has to be True in the corresponding solver wrappers.","title":"Test Examples"},{"location":"test_examples/#test-examples","text":"This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube.","title":"Test Examples"},{"location":"test_examples/#folder-and-file-structure","text":"This section describes the different folders and files which are provided. MainKratos.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X readme.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run.","title":"Folder and file structure"},{"location":"test_examples/#running-a-case","text":"In order to run a test example, the case have to be made ready by running the setup files for both solvers. Then, the calculation is started by running MainKratos.py with the parameter file as argument.","title":"Running a case"},{"location":"test_examples/#debug-files","text":"The folder test_examples also contains a folder debug_files with files for debug purposes. In order to use those, the debug boolean self.debug has to be True in the corresponding solver wrappers.","title":"Debug files"},{"location":"tube_fluent2D_abaqus2D/","text":"Description of tube2D_fluent_abaqus This documentation describes the test example tube2D_fluent_abaqus. Solvers The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus, used to solve an axisymmetric representation of a tube. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 2D - Abaqus 2D"},{"location":"tube_fluent2D_abaqus2D/#description-of-tube2d_fluent_abaqus","text":"This documentation describes the test example tube2D_fluent_abaqus.","title":"Description of tube2D_fluent_abaqus"},{"location":"tube_fluent2D_abaqus2D/#solvers","text":"The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus, used to solve an axisymmetric representation of a tube. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_fluent2D_tube_structure/","text":"Description of fluent_pipe_structure This documentation describes the test example fluent_pipe_structure. Solvers The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is the 2D pipe_structure_inert solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 2D - Python"},{"location":"tube_fluent2D_tube_structure/#description-of-fluent_pipe_structure","text":"This documentation describes the test example fluent_pipe_structure.","title":"Description of fluent_pipe_structure"},{"location":"tube_fluent2D_tube_structure/#solvers","text":"The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is the 2D pipe_structure_inert solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_fluent3D_abaqus3D/","text":"Description of tube3D_fluent_abaqus This documentation describes the test example tube3D_fluent_abaqus. Solvers The flow solver is fluent. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 3D - Abaqus 3D"},{"location":"tube_fluent3D_abaqus3D/#description-of-tube3d_fluent_abaqus","text":"This documentation describes the test example tube3D_fluent_abaqus.","title":"Description of tube3D_fluent_abaqus"},{"location":"tube_fluent3D_abaqus3D/#solvers","text":"The flow solver is fluent. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_tube_flow_abaqus2D/","text":"Description of pipe_flow_abaqus This documentation describes the test example pipe_flow_abaqus. Solvers The flow solver is pipe_flow, a 1D solver which communicates as a 2D solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. The structure solver is abaqus, which solves an axisymmetric case. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Python - Abaqus 2D"},{"location":"tube_tube_flow_abaqus2D/#description-of-pipe_flow_abaqus","text":"This documentation describes the test example pipe_flow_abaqus.","title":"Description of pipe_flow_abaqus"},{"location":"tube_tube_flow_abaqus2D/#solvers","text":"The flow solver is pipe_flow, a 1D solver which communicates as a 2D solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. The structure solver is abaqus, which solves an axisymmetric case. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure/","text":"Description of 04_tube This documentation describes the test example 04_tube. Solvers The flow solver is the pipe_flow solver. The structure solver is the pipe_structure solver.","title":"Python - Python"},{"location":"tube_tube_flow_tube_structure/#description-of-04_tube","text":"This documentation describes the test example 04_tube.","title":"Description of 04_tube"},{"location":"tube_tube_flow_tube_structure/#solvers","text":"The flow solver is the pipe_flow solver. The structure solver is the pipe_structure solver.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure_inert/","text":"Description of 04_tube2D This documentation describes the test example 04_tube2D. Solvers The flow solver is the pipe_flow solver. The structure solver is the pipe_structure_inert solver.","title":"Python - Python inert"},{"location":"tube_tube_flow_tube_structure_inert/#description-of-04_tube2d","text":"This documentation describes the test example 04_tube2D.","title":"Description of 04_tube2D"},{"location":"tube_tube_flow_tube_structure_inert/#solvers","text":"The flow solver is the pipe_flow solver. The structure solver is the pipe_structure_inert solver.","title":"Solvers"}]}