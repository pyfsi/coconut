{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#coupling-code-for-numerical-tools","title":"Coupling Code for Numerical Tools","text":"<p>CoCoNuT is a light-weight Python package for efficient partitioned multi-physics simulations, with a focus on fluid-structure interaction.  Thanks to its fully modular approach, the package is versatile and easy to extend. It is available under the GPL-3.0 license. </p>"},{"location":"index.html#introduction","title":"Introduction","text":"<p>The Coupling Code for Numerical Tools \u2014 CoCoNuT in short \u2014 follows a partitioned approach to solve multi-physics problems: existing single-physics solvers are coupled through a Python interface.  This has the advantage that dedicated, highly-optimized single-physics solvers can be used.  To use the code with a new solver (open source or commercial), a so-called solver wrapper is written to take care of the communication with CoCoNuT.  All other CoCoNuT components, such as mapping for non-conformal meshes, are solver-independent and are easily swapped thanks to CoCoNuT's modular architecture. </p> <p>CoCoNuT is under active development by the Fluid Mechanics research team at Ghent University.  Our specialization is partitioned fluid-structure interaction.  We develop high-performance quasi-Newton algorithms to accelerate convergence of the coupled problem, and apply these techniques to diverse fluid-structure interaction applications such as wind turbines, tube bundles and flexible aircraft. </p> <p>The full documentation of the CoCoNuT package can be found at the documentation website.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>These instructions describe the setup of CoCoNuT on Linux. The package has not been tested on Windows or macOS, so compatibility is not guaranteed, although we do not expect major issues. </p>"},{"location":"index.html#requirements","title":"Requirements","text":"<ul> <li><code>python&gt;=3.6.8</code> </li> <li><code>numpy&gt;=1.19.5</code></li> <li><code>scipy&gt;=1.3.0</code></li> <li><code>pandas&gt;=1.0.0</code> (required for Kratos solver wrapper)</li> <li><code>matplotlib=3.1.3</code> (recommended)</li> </ul> <p>We recommend Anaconda 2019.07 or newer.</p>"},{"location":"index.html#installation-procedure","title":"Installation procedure","text":"<p>CoCoNuT does not need to be compiled, hence installation is straightforward.  The source code can be downloaded as a zip file, or cloned directly from GitHub. For users that have no experience with Git or GitHub, we recommend the first option. The second option makes it easier to update the software and contribute to the code. </p> <p>Option 1: download zip</p> <ul> <li>Download the source code from GitHub.</li> <li>Unzip to a folder <code>coconut</code>. If the folder is unzipped in Windows, some file permissions may change and some tests or examples may not run out of the box. </li> </ul> <p>Option 2: clone source</p> <ul> <li>Choose or create a directory to install CoCoNuT. </li> <li>Move to this directory. </li> <li> <p>Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. </p> <ul> <li>With SSH:</li> </ul> <pre><code>git clone git@github.com:pyfsi/coconut.git\n</code></pre> <ul> <li>With HTTPS:</li> </ul> <pre><code>git clone https://github.com/pyfsi/coconut.git\n</code></pre> </li> </ul> <p>After the code has been downloaded or cloned, the <code>coconut</code> folder must be added to the user's Python path.  For example, with a folder structure like</p> <pre><code>/some/absolute/path/\n    coconut/\n        coupling_components/\n        data_structure/\n        ...\n        README.md\n</code></pre> <p><code>coconut</code> can be added to your Python path by executing the following line:</p> <pre><code>export PYTHONPATH=/some/absolute/path:$PYTHONPATH\n</code></pre> <p>This line can also be added to your <code>.bashrc</code> file.</p>"},{"location":"index.html#checking-the-solver-modules","title":"Checking the solver modules","text":"<p>Before using CoCoNuT, it is necessary to adapt some system specific commands in the <code>solver_modules.py</code> file in the <code>coconut</code> folder. This file has the commands to load solver modules in separate environments when running a case, to avoid conflicts. As these commands are system specific, it is important to check this file before testing CoCoNuT.  The file contains a nested dictionary <code>solver_load_cmd_dict</code>, which has keys such as <code>ugent_cluster_SL6.3</code> or <code>ugent_cluster_CO7</code> denoting the machine on which CoCoNuT is installed. In their turn, each of these dictionaries contains keys for all solvers that are available on that machine and can be used in CoCoNuT.  The values are strings containing terminal commands to load the software, thus setting the environment which allows running the solver.  For example, on the UGent cluster, the Lmod system is used, but there is no general guideline on how to make the solvers' software available as long as it is compatible with your system's command-line-interface.  If multiple commands are needed, they should appropriately be separated within the string. For example in a Linux terminal the semicolon (;) or double ampersand (&amp;&amp;) can be used. Since <code>machine_name</code> is set to <code>ugent_cluster_CO7</code>, this dictionary is used by default. In case your system differs from the <code>ugent_cluster_CO7</code> settings, it is advised to add your own internal dictionary to <code>solver_load_cmd_dict</code> and provide this key to <code>machine_name</code>. If a solver module is not present on your system the key should be removed. If a solver module is always present, i.e. no module load command or similar action is needed, an empty string should be given as value. When CoCoNuT tries to use a solver module that is not present in the <code>solver_load_cmd_dict</code> or that has the wrong value, an error will be raised.</p>"},{"location":"index.html#quick-test","title":"Quick test","text":"<p>We recommend to run the unit tests at the end of the installation, to make sure that everything works. </p> <ul> <li>Ensure that <code>coconut</code> is included in your Python path.</li> <li>Move to the <code>coconut/tests</code> directory. </li> <li>Run the fast unit tests (excluding the non-Pythonic solvers) by executing the following line: <pre><code>python3 run_tests.py\n</code></pre></li> <li>Or choose to include the solver wrapper tests by using the keyword <code>-all</code> as follows <pre><code>python3 run_tests.py -all\n</code></pre> More information on running tests can be found here.</li> </ul>"},{"location":"index.html#getting-started","title":"Getting started","text":"<p>Once the CoCoNuT package has been successfully installed, it is time to run a first coupled simulation. For this purpose, we give a step-by-step guide of an example case included in the source code.</p> <p>In this example the fluid-structure interaction (FSI) problem of a pressure wave propagating through an elastic tube in incompressible flow is calculated [1, 2]. For both the flow and structural solver, we use 1D Python-solvers that are included in CoCoNuT. This has the advantage that no external single-physics solvers must be installed for this example. Furthermore, the 1D solvers are very fast, so that a full transient FSI calculation can be done in this example. Other example cases in the source code solve the same FSI problem with ANSYS Fluent or OpenFOAM as flow solver and Abaqus or Kratos as structural solver. </p> <p>We start by creating a variable <code>COCO</code> in which we can store the path to the folder in which CoCoNuT is installed. We will use this variable to avoid any confusion about relative or absolute paths in this tutorial. Using the example installation location from above:</p> <pre><code>COCO=/some/absolute/path\n</code></pre> <p>We can now navigate to the folder of the example we will simulate.  <pre><code>cd $COCO/coconut/examples/tube/tube_flow_tube_structure/\n</code></pre> This folder serves as main directory to set up and run the FSI simulation from in CoCoNuT. The file <code>parameters.json</code> will be used to run the actual FSI simulation, but we will come back to that later.  First we must set up both single-physics solvers separately. This setup is typically done outside CoCoNuT by the user, as it is solver and case specific.  In this case we provide a script <code>setup_case.py</code> that sets up both solvers using the files in the folder <code>../setup_files</code>. When the script is run with</p> <pre><code>python3 setup_case.py\n</code></pre> <p>new folders <code>CFD</code> and <code>CSM</code> appear, as well as the file <code>run_simulation.py</code>. The <code>CFD</code> folder contains all files required to start a simulation of the flow in the tube.  Analogously, the <code>CSM</code> folder contains all files required to start a simulation of the tube structure.</p> <p>We can now start the FSI simulation in CoCoNuT by running the Python file <code>run_simulation.py</code>:</p> <pre><code>python3 run_simulation.py\n</code></pre> <p>The simulation should start, first printing the CoCoNuT ASCII-banner and some information about the settings of the FSI simulation. Then the simulation itself starts: in each time step, the residual is given for every coupling iteration. When the simulation has finished, a summary about the computational effort is printed.</p> <p>Let us now take a closer look at the two files that are used to run CoCoNuT.  The Python file <code>run_simulation.py</code> typically does not have to be adapted by the user. Its task is to read in the settings file <code>parameters.json</code> and launch a simulation using those settings.  The file <code>parameters.json</code> is a collection of settings that is written in JSON format. JSON is a language-independent text format that is easy to read and write, and is used for data-exchange.  It consists mainly of key-value pairs, and can hence be easily converted to a (nested) Python dictionary. While the keys are always strings, the values can be strings, numbers, arrays, booleans or nested JSON objects (nested dictionaries). Before you read on, it can be useful to familiarize yourself with the JSON syntax. In what follows, we will use Python terminology (dictionary, list, boolean, etc...) to refer to the structure and the values in the JSON file. </p> <p>The JSON file is built up in a hierarchical way that represents the objects created in the CoCoNuT simulation. At the highest level, the dictionary contains two keys: <code>settings</code> and <code>coupled_solver</code>.  The value given to the <code>settings</code> key is a nested dictionary, which contains a single key-value pair that sets the number of time steps to be simulated.  The value given to the <code>coupled_solver</code> key is a special dictionary, because it has the <code>type</code> key. CoCoNuT will generate an object of the specified type, namely <code>coupled_solvers.iqni</code>. This refers to the class defined in the file <code>$COCO/coconut/coupling_components/coupled_solvers/iqni.py</code>: the <code>CoupledSolverIQNI</code> class.  Note that the value in <code>type</code> always refers to a file located in <code>$COCO/coconut/coupling_components</code>.  The dictionary under <code>settings</code> is used to initialize an instance of this class. In this case the initial time <code>timestep_start</code>, the time step <code>delta_t</code> and some other parameters must be given. The coupled solver is the main class that determines how the two single-physics solvers are coupled.  The dictionary that is given to the <code>coupled_solver</code> key contains next to <code>type</code> and <code>settings</code> three other key-value pairs. These will generate other objects: the fact that they are given in the <code>coupled_solver</code> dictionary means that these objects will be created by the coupled solver object.</p> <p><code>predictor</code> will generate an object of the <code>PredictorLinear</code> class found in the file <code>$COCO/coconut/coupling_components/predictors/linear.py</code>. This class requires no additional settings for its initialization. The predictor object is used to extrapolate the solution to the next time step. </p> <p><code>convergence_criterion</code> will generate an object of the <code>ConvergenceCriterionOr</code> class found in the file <code>$COCO/coconut/coupling_components/convergence_criteria/or.py</code>, using the given <code>settings</code> for its initialization. The convergence criterion is used to determine when CoCoNuT should move to the next time step. In this case the or criterion is used, which signals convergence when one or both underlying criteria are satisfied. These underlying criteria are instances of the <code>ConvergenceCriterionIterationLimit</code> and <code>ConvergenceCriterionRelativeNorm</code> classes defined in respectively <code>$COCO/coconut/coupling_components/convergence_criteria/iteration_limit.py</code> and <code>$COCO/coconut/coupling_components/convergence_criteria/relative_norm.py</code>.  This means that CoCoNuT will move to the next time step after 15 iterations or when the 2-norm of the residual has decreased six orders of magnitude.</p> <p><code>solver_wrappers</code> is a list of two solver wrapper objects, which will communicate with the two single-physics solvers, in this case the 1D flow solver and the 1D structural solver. The first dictionary in the list will generate an instance of the <code>SolverWrapperTubeFlow</code> class found in <code>$COCO/coconut/coupling_components/solver_wrappers/python/tube_flow_solver.py</code>. An important setting to generate this object is the <code>working_directory</code>, which refers to the folder <code>CFD</code> that we created with the case files of the flow solver. All files written by the flow solver will also appear in this folder. We would now expect the second dictionary to generate a solver wrapper to communicate with the structural solver, i.e. an instance of the <code>SolverWrapperTubeStructure</code> class found in <code>$COCO/coconut/coupling_components/solver_wrappers/python/tube_structure_solver.py</code>. This is not the case however: the flow and structural solvers typically use a different geometrical discretization (computational grid or mesh), hence they cannot readily be coupled in CoCoNuT. To overcome this issue, we put a layer of mapping around one of the solver wrappers. This is done with the <code>SolverWrapperMapped</code> class found in <code>$COCO/coconut/coupling_components/solver_wrappers/mapped.py</code>. The mapped solver wrapper interpolates all data flowing between the coupled solver and the real solver wrapper. The mapped solver wrapper itself contains three objects: the actual solver wrapper (<code>SolverWrapperTubeStructure</code> class), and mappers for respectively the input and the output of the solver wrapper (both <code>MapperInterface</code> class, found in <code>$COCO/coconut/coupling_components/mappers/interface.py</code>). </p> <p>The concept of the mapped solver wrapper illustrates the modularity of CoCoNuT. As far as the coupled solver is concerned, the mapped solver wrapper acts exactly as a real solver wrapper. The real solver wrapper does not know about the mapping at all: it acts as if it directly communicates with the coupled solver. Furthermore, the interpolation method can be easily changed by swapping the mappers in the mapped solver wrapper: the current linear interpolation scheme can for example be replaced by a radial basis scheme by changing <code>mappers.linear</code> to <code>mappers.radial_basis</code>. </p> <p>Now try to change some settings in the JSON file, such as the mappers, the time step or the maximum number of coupling iterations, and rerun the coupled simulation.</p> <p>After a simulation is finished, it can be useful to inspect or visualize the output quantities (i.e. displacement, pressure and in general also shear). CoCoNuT has some built-in tools to do just that described in the post-processing documentation. For the FSI-simulation we have just performed, an example script is present in <code>$COCO/coconut/examples/post_processing/</code>. It requires the <code>save_results</code> setting in the <code>coupled_solver</code> part of the JSON-file to be set on a non-zero integer, which is for all examples done by default. By running this example script <code>animate_example.py</code>, we will generate several animations:</p> <pre><code>python3 $COCO/coconut/examples/post_processing/animate_example.py\n</code></pre> <p>Animations of the displacement, pressure and coordinates (with equally scaled axes) will be shown. The first two are shown below.</p> <p> </p>"},{"location":"index.html#overview-of-the-code","title":"Overview of the code","text":"<p>The CoCoNuT package consists of 5 main folders: <code>coupling_components</code>, <code>data_structure</code>, <code>docs</code>, <code>examples</code> and <code>tests</code>. To give a general understanding of how the code is structured, we give a brief description of the purpose of each folder. The documentation website mirrors this folder structure and the folder names below link to the corresponding page.</p>"},{"location":"index.html#coupling_components","title":"<code>coupling_components</code>","text":"<p>This folder contains the basic building blocks of CoCoNuT, which can be used to set up a coupled simulation. This includes among others the solver wrappers, to communicate with single-physics solvers, and the mappers, which provide interpolation between non-conforming meshes present in the different single-physics solvers.</p>"},{"location":"index.html#data_structure","title":"<code>data_structure</code>","text":"<p>This folder contains the data structure that is used internally in CoCoNuT to store and pass around information obtained from the single-physics solvers. The data structure relies on NumPy arrays for efficient storage and manipulation of data.</p>"},{"location":"index.html#docs","title":"<code>docs</code>","text":"<p>This folder serves to automatically generate the documentation website, based on the MarkDown documentation files that are present throughout the code. </p>"},{"location":"index.html#examples","title":"<code>examples</code>","text":"<p>This folder contains examples of several fluid-structure interaction cases, which can serve as starting point for settings up the user's own simulation. They also provide insight into the capabilities of CoCoNuT.</p>"},{"location":"index.html#tests","title":"<code>tests</code>","text":"<p>This folder contains the unit tests. These are created for each piece of code that is added to CoCoNuT and are run regularly, to avoid bugs. </p>"},{"location":"index.html#references","title":"References","text":"<p>[1] Delaiss\u00e9 N., Demeester T., Haelterman R. and Degroote J., \"Quasi-Newton methods for partitioned simulation of fluid-structure interaction reviewed in the generalized Broyden framework\", Archives of Computational Methods in Engineering, vol. 30, pp. 3271-3300, 2023.</p> <p>[2] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Surrogate-based acceleration of quasi-Newton techniques for fluid-structure interaction simulations\", Computers &amp; Structures, vol. 260, pp. 106720, 2022.</p>"},{"location":"abaqus.html","title":"Abaqus","text":"<p>This is the documentation for all Abaqus solver wrappers. Abaqus is a structural solver implementing the finite element method. Currently, this wrapper only supports FSI simulations, no other multi-physics problems.  Subcycling within the structural solver is possible.</p>"},{"location":"abaqus.html#fluid-structure-interaction-with-abaqus","title":"Fluid-structure interaction with Abaqus","text":"<p>Abaqus (Dassault Syst\u00e8mes) can be used to solve for the structural displacement/deformation in partitioned FSI-simulations. The FSI interface consist of a surfaces in the Abaqus model, where pressure and surface traction loads are applied, and corresponding node sets, where the resulting computed displacements are returned to the solver wrapper. The loads are applied in so-called load points (Gauss points, quadrature points), the displacements are exported in the elements' nodes. The input loads are collected in one or more <code>ModelParts</code> in the input <code>Interface</code>, the output nodes are collected in one or more <code>ModelParts</code> of the output <code>Interface</code>. Each <code>ModelPart</code> on the input <code>Interface</code> has a counterpart on the output <code>Interface</code>. More information about <code>ModelParts</code> and <code>Interface</code> can be found in the data structure documentation.</p>"},{"location":"abaqus.html#terminology","title":"Terminology","text":"<ul> <li>Main directory: Directory where the analysis is started.</li> <li>Working directory: Subdirectory of the main directory in which Abaqus runs.</li> <li>Source directory: Directory where the source files of the Abaqus solver wrapper are found: <code>coupling_components/solver_wrappers/abaqus</code>.</li> <li>Extra directory: Subdirectory of the source directory with some files to assist with the setup.</li> <li>Geometrical nodes: Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. </li> <li>Load points: Every element has load points. This is where the loads (input to Abaqus) are applied.</li> <li>Time step: Time step from the viewpoint of the fluid-structure interaction, usually equal to the time-step of the flow solver and structural solver, although one of the solvers can deviate in the case of subcycling.</li> <li>Increment: Time increment in the nomenclature of the Abaqus software. This is usually equal to the time step of the flow solver and overall coupled simulation, but in case of subcycling within the Abaqus solver, a time step can be subdivided in multiple increments.</li> </ul>"},{"location":"abaqus.html#environment","title":"Environment","text":"<ul> <li>A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the JSON file. In the CoCoNuT examples this folder is typically called <code>CSM</code>, but any name is allowed.</li> <li>The Abaqus software should be available as well as compilers to compile the user-subroutines (FORTRAN) and post-processing code (C++). Some compilers also require a license. </li> <li>If the Abaqus license server needs to be specified explicitly, it is advised to do this in the solver modules file.</li> </ul>"},{"location":"abaqus.html#parameters","title":"Parameters","text":"<p>This section describes the parameter settings in the JSON file. A distinction is made between mandatory and optional parameters. It can be useful to have a look at a JSON file of one of the examples in the <code>examples</code> folder.</p>"},{"location":"abaqus.html#mandatory","title":"Mandatory","text":"parameter type description <code>arraysize</code> int Size specification for array in FORTRAN part of the code, to reserve sufficient memory. Should be large enough and depends on the number of load points in the structural model. <code>cores</code> int Number of cores to be used by Abaqus. <code>delta_t</code> float Size of the time step in Abaqus. Its value should be synchronized with the flow solver. This parameter is usually specified in a higher <code>Component</code> object in which case it is not mandatory. <code>dimensions</code> int Dimensionality of the problem (2 or 3). <code>interface_input</code> list Should contain a dictionary for each input <code>ModelPart</code> to be created, having a key <code>\"model_part\"</code> that provides the name of a <code>ModelPart</code> for Abaqus load points as value. The name should correspond to the Surfaces created in Abaqus concatenated with \"_load_points\". The second key of the dictionary is <code>variables</code>. The list given as value specifies the input variables that should be included, chosen from <code>data_structure/variables.py</code>. Currently only <code>\"pressure\"</code> and <code>\"traction\"</code> are allowed. The order of should correspond to the <code>interface_output</code> as well as the other solver wrapper's <code>Interface</code> definitions to which Abaqus is coupled. An example can be found in this part of the input file section. <code>interface_output</code> list Similar to <code>interface_input</code> but contains the output <code>ModelParts</code> for Abaqus geometrical nodes. The name has to correspond to the Node Sets created in Abaqus, concatenated with \"_nodes\". In this case the <code>\"variables\"</code> key specifies the output variable, chosen from <code>data_structure/variables.py</code>.  Currently only <code>\"displacement\"</code> is allowed. The order of should correspond to the <code>interface_input</code> as well as the other solver wrapper's <code>Interface</code> definitions to which Abaqus is coupled. An example can be found in this part of the input file section. <code>input_file</code> str Name of the Abaqus input file (.inp) provided by the user.  Example: <code>\"case.inp\"</code> <code>timestep_start</code> int Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher <code>Component</code> in which case it is not mandatory to specify. <code>working_directory</code> str Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution, see the environment section. <p><code>timestep_start</code> and <code>delta_t</code> are necessary parameters, but are usually defined in a higher <code>Component</code>. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed.</p>"},{"location":"abaqus.html#optional","title":"Optional","text":"parameter type description <code>debug</code> bool Default: <code>false</code>. For every iteration, text files are saved with the input and output data of the solver. <code>ramp</code> bool Default: <code>false</code>. Only used when automatic time incrementation (subcycling) is enabled in Abaqus.  <code>false</code>: Load is considered to be constant throughout the time step. <code>true</code>: Load is applied in a ramped fashion throughout the time step. <code>save_results</code> int Default: <code>1</code>. Determines what output files are kept by Abaqus. Only the <code>.odb</code> files corresponding to (i.e. of which the time step is a multiple of) <code>save_results</code> are kept at the end of a time step."},{"location":"abaqus.html#overview-of-operation","title":"Overview of operation","text":"<p>The solver wrapper consists of 6 types of files located in the source directory (with <code>X</code> denoting the Abaqus version, e.g. <code>v2022.py</code>):</p> <ul> <li><code>abaqus.py</code>: Contains the base class <code>SolverWrapperAbaqus</code>.</li> <li><code>X.py</code>: Defines the <code>SolverWrapperAbaqusX</code>class, which inherits from the base class. Some version specific parameters might be overwritten in these subclasses. </li> <li><code>abaqus_v6.env</code>: Environment file setting the environment for the Abaqus solver.</li> <li><code>GetOutput.cpp</code>: Extracts the output (from Abaqus .odb files) and writes it to a file for each output<code>ModelPart</code>. Written in C++.</li> <li><code>USR.f</code>: An Abaqus user-subroutine that reads the loads from files (one for each input <code>ModelPart</code>) and applies them on the load points. Written in FORTRAN.</li> <li><code>USRInit.f</code>: An Abaqus user-subroutine that extract the coordinates of the load points and writes them to files (one for each input <code>ModelPart</code>) to initialize each input <code>ModelPart</code>. Written in FORTRAN.</li> </ul>"},{"location":"abaqus.html#the-initialize-method","title":"The <code>initialize</code> method","text":"<p>During initialization of the <code>SolverWrapperAbaqusX</code> object, some parameters are substituted in <code>abaqus_v6.env</code>, <code>GetOutput.cpp</code>, <code>USR.f</code> and <code>USRInit.f</code> and these files are copied to the working directory.   The C++ files and FORTRAN files are subsequently compiled. USRInit is ran to obtain the coordinates of the load points at the Surfaces defined in Abaqus.  These coordinates are stored in <code>ModelParts</code> of which the name corresponds to the entries in <code>interface_input</code>.  GetOutput is ran to extract the coordinates of the geometrical nodes. These coordinates are added to <code>ModelParts</code> of which the names corresponds to entries of <code>interface_output</code>.  The input <code>ModelParts</code> are added to an <code>Interface</code> object taking care of the inputs (i.e. loads), the output <code>ModelParts</code> to another instance of <code>Interface</code>taking care of outputs (i.e. displacements).</p>"},{"location":"abaqus.html#files-written-in-the-working-directory-during-initialize","title":"Files written in the working directory during <code>initialize</code>","text":"<p>In the file conventions <code>A</code> is the index of the corresponding element in the <code>interface_input</code> or <code>interface_output</code> list.</p> <ul> <li>The Abaqus input file (<code>input_file</code> in JSON file) is processed into a file <code>CSM_Time0.inp</code> and <code>CSM_Restart.inp</code>, the latter taking care of all simulations (i.e. coupling iterations) but the first.</li> <li>Upon running USRInit the load point coordinates of each surface are written to <code>CSM_Time0Cpu0SurfaceAFaces.dat</code>. When these are processed by the solver wrapper, also <code>CSM_Time0SurfaceAElements.dat</code> is created.</li> <li>Upon running GetOutput the geometrical nodes are written to <code>CSM_Time0SurfaceANodes.dat</code>. </li> </ul> <p>Note that the <code>CSM_Time0.inp</code> and <code>CSM_Restart.inp</code> are created each initialization (even during restart), however the USRInit and GetOutput are only run when <code>timestep_start</code> equals 0.</p>"},{"location":"abaqus.html#the-solve_solution_step-method","title":"The <code>solve_solution_step</code> method","text":"<p>This method of <code>SolverWrapperAbaqusX</code> is called each coupling iteration with an <code>Interface</code> object (input_interface) containing loads, which are written to files that are read by the (compiled) <code>USR.f</code> during the invoked Abaqus simulation. The Abaqus software is started and shut down for each calculation, i.e. each coupling iteration. When the simulation has ran successfully (log-file <code>abaqus.log</code> is checked for errors), the outputs are read from Abaqus by GetOuput and written to a file. The file is read in Python and the output (displacements) are stored in the output <code>Interface</code> object which is returned.</p>"},{"location":"abaqus.html#files-written-in-the-working-directory-during-solve_solution_step","title":"Files written in the working directory during <code>solve_solution_step</code>","text":"<p>In the file conventions <code>A</code> is the index of the corresponding element in the <code>interface_input</code> or <code>interface_output</code> list and <code>B</code> the time step.</p> <ul> <li>Files written by Abaqus for allowing a restart (required every coupling iteration): <code>CSM_TimeB.odb</code>, <code>CSM_TimeB.res</code>, <code>CSM_TimeB.mdl</code>, <code>CSM_TimeB.prt</code>, <code>CSM_TimeB.stt</code>.</li> <li>Output database file written by Abaqus called <code>CSM_TimeB.odb</code> and read by GetOutput (also needed for restart).</li> <li>Output text file <code>CSM_TimeBSurfaceAOutput.dat</code> containing displacements written by GetOutput and read by the solver wrapper.</li> <li>Input text file <code>CSM_TimeBSurfaceACpu0Input.dat</code> containing the loads written by the solver wrapper and read by the USR.</li> </ul> <p>The parameter <code>save_restart</code> (defined at the level of the <code>coupled_solver</code>) determines at which time steps these files are saved.  Additionally, the <code>save_results</code> parameter defines the rate at which the output database files (<code>.odb</code>) are kept.</p>"},{"location":"abaqus.html#setting-up-a-case-abaqus-input-file-inp","title":"Setting up a case: Abaqus input file (.inp)","text":"<p>The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory. Its name should be specified in the JSON file via the parameter <code>input_file</code>. For the remainder of this section this file will be referred to as \"base-file\".</p> <p>Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file.</p>"},{"location":"abaqus.html#general","title":"General","text":"<p>The base-file needs to be of the \".inp\" type, this is an \"input file for Abaqus\". \".inp-files\" are created via Abaqus by, after configuration, creating a \"job\" and requesting a \"write input\" for that job. These files can be opened in Abaqus by using \"file &gt; import &gt; model\". The base-file has to contain all necessary information about the structural model, which includes:</p> <ul> <li>Mesh defining the structure geometry and discretization.<ul> <li>Also the element type needs to be defined.</li> </ul> </li> <li>Material properties.</li> <li>Boundary conditions.</li> <li>Surfaces where external loads need to be applied (one surface per <code>ModelPart</code>).<ul> <li>Here \"Surface\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree.</li> </ul> </li> <li>Per surface a pressure load and traction load should be defined (see below).</li> <li>Node sets where displacement data will be extracted.<ul> <li>Here \"Set\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree. Also element sets exist, but for CoCoNuT the demanded sets need to be a collection of geometrical nodes, hence \"node set\".</li> </ul> </li> <li>A Field Output Request requesting output at the node sets (see below).</li> <li>A Step definition, which contains solver settings. Currently, the following type of analyses are supported (it is advised to explicitly set them based on this documentation rather than leaving it to Abaqus to fill in a default):<ul> <li>Implicit dynamic, application quasi-static</li> <li>Implicit dynamic, application moderate dissipation</li> <li>Implicit dynamic, application transient fidelity</li> <li>Static general</li> </ul> </li> <li>Additional loads not dependent on the flow solver.</li> </ul> <p>Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Also the sets and surfaces required by CoCoNuT should be defined on the assembly level.</p> <p>Abaqus has a GUI as well as a Python 2 interface (which is also accessible) via the GUI. References to both the Python interface and GUI will be made below.</p>"},{"location":"abaqus.html#setup-for-abaqus-input-loads","title":"Setup for Abaqus input (loads)","text":"<p>Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \"surface\" should be created in the assembly. There are multiple possibilities to create these surfaces:</p> <ul> <li>From the geometry: when the geometry has been defined in Abaqus itself, the geometry faces can easily be selected in the GUI. This method is often the most straightforward, but the Abaqus model should contain the geometry.</li> <li>From the mesh: when the geometry is not available (this can for example be the case when a mesh has been imported), a surface can be defined by selecting multiple mesh faces. As a surface typically covers many mesh faces, it is useful there to select the regions \"by angle\", which uses the angle between mesh faces to determine whether adjacent faces should be selected. This way the surface selection can be extended until a sharp corner is met.</li> <li>By converting a \"node set\" containing all the nodes on the surface and then calling the <code>SurfaceFromNodeSet</code> method which can be found in the <code>make_surface.py</code> file in the extra directory. It is advised to copy this file to the working directory.</li> </ul> <p>An example on the use of <code>SurfaceFromNodeSet</code> (via the Python console in Abaqus or a Python script for Abaqus): <pre><code>from make_surface import SurfaceFromNodeSet\nmy_model = mdb.models['Model-1']\nmy_assembly = my_model.rootAssembly  \nmy_instance = my_assembly.instances['PART-1-1']\ninputSurfaceA = SurfaceFromNodeSet(my_assembly, my_instance, 'NODESET_NAME_A', 'SURFACE_NAME_A')\n</code></pre></p> <p>On these surfaces a \"pressure load\" and a \"surface traction load\" need to be specified with a \"user-defined\" distribution. Loads are assigned to a \"step\". A step is a part of the simulation to which an analysis type, algorithm settings and incrementation settings are assigned that do not change for the duration of the step. In a typical CoCoNuT case only a single step is defined. Note that the name of the step used for the FSI has to be \"Step-1\" as this name is hardcoded in <code>GetOutput.cpp</code>. After creation of the step the loads can be assigned. It is required to have the <code>initialConditons=OFF</code> part when using <code>application=TRANSIENT FIDELITY</code> (beware that when application is not specified, transient fidelity is the default). This makes sure that for each time step the accelerations from the previous time step are used. This can be done via the GUI or using Python commands available in Abaqus similar to the following:</p> <pre><code>from step import *\nstep1 = my_model.ImplicitDynamicsStep(name='Step-1', previous='Initial', timePeriod=1, nlgeom=ON, maxNumInc=1, haftol=1, initialInc=1, minInc=1, maxInc=1, amplitude=RAMP, noStop=OFF, nohaf=ON, initialConditions=OFF, timeIncrementationMethod=FIXED, application=QUASI_STATIC)\nstep1.Restart(frequency = 99999, overlay = ON)\nmy_model.Pressure(name = 'DistributedPressure', createStepName = 'Step-1', distributionType = USER_DEFINED, field = '', magnitude = 1, region=inputSurfaceA)\nmy_model.SurfaceTraction(name = 'DistributedShear', createStepName = 'Step-1', region = inputSurfaceA, magnitude = 1, traction = GENERAL, directionVector = ((0,0,0), (1,0,0)), distributionType = USER_DEFINED)\n</code></pre> <p>The second command enables writing of restart files by Abaqus, which is required for running unsteady cases. This can be done from the GUI when the \"Step\" module is active in the viewport, by selecting \"Output\" in the top menu and subsequently \"Restart Requests\". Frequency should be put on 99999, overlay activated (this spares disk space since only the last increment is kept) and interval on 1 (also see this Abaqus documentation page). Note that the step type \"ImplicitDynamicsStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\":</p> <pre><code>step1 = my_model.StaticStep(name='Step-1', previous='Initial', timePeriod=1.0, initialInc=1, minInc=1e-4, maxNumInc=10, nlgeom=ON, amplitude=RAMP)\n</code></pre> <p>The Abaqus wrapper tries to check if the increments comply with the <code>delta_t</code> setting and if needed adjusts it accordingly (notifying the user by raising a warning). The lines in the base-file (.inp) can look similar to this:</p> <pre><code>*Step, name=Step-1, nlgeom=YES, inc=1\n*Dynamic,application=QUASI-STATIC,direct,nohaf,initial=NO\n0.0001,0.0001,\n</code></pre> <p>It is required to have <code>initial=NO</code> when using the application transient fidelity (default when no application specified). This corresponds to the <code>initialConditons=OFF</code> setting when creating a step using Python. As mentioned earlier, this makes sure that for each time step the accelerations from the previous time step are used. The time step (0.0001) will in this case be replaced by settings found in the JSON file. More information for dynamic cases can be found on this Abaqus documentation page, for static cases on this page.</p>"},{"location":"abaqus.html#input-related-settings-in-json-file","title":"Input-related settings in JSON file","text":"<p>The name of the surface has to be put as value for the <code>\"model_part\"</code> key in the <code>interface_input</code> list, but with \"_load_points\" appended to it. If multiple surfaces are defined, their geometry should match those in the flow solver wrapper counterpart and be listed in the same order.</p> <pre><code>{\n  \"interface_input\": \n  [\n    {\n      \"model_part\": \"SURFACE_NAME_A_load_points\",\n      \"variables\": [\"pressure\", \"traction\"]\n    },\n    {\n      \"model_part\": \"SURFACE_NAME_B_load_points\",\n      \"variables\": [\"pressure\", \"traction\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"abaqus.html#setup-for-abaqus-output-displacements","title":"Setup for Abaqus output (displacements)","text":"<p>After creation of the step, Abaqus needs to be instructed about what to output at the end of a calculation. A \"Field Output\" has to be generated covering all locations involved in the fluid-structure interface. To do so one must create node sets in the assembly (if this had not been done before) containing all structural nodes of the surfaces, then create a Field Output Request for at least the coordinates and the displacements. This Field Output Request can in the GUI be found as part of the model tree, but below also an example for the Python interface is given. A Field Output Request requests field output (as the name says) to be written to the output database file (.odb).</p> <p>In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created):</p> <pre><code>my_assembly = my_model.rootAssembly\ninputSurfaceA = my_assembly.surfaces[\"SURFACE_NAME_A\"]\noutputSetA = my_assembly.Set(name='NODESET_NAME_A', nodes=inputSurfaceA.nodes)\nmy_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-1', region=my_assembly.sets['NODESET_NAME_A'], variables=('COORD', 'U'))\n</code></pre> <p>Furthermore, it may be interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a Field Output and History Output with PRESELECTED variables. This can be done via the GUI or using Python lines similar to the following:</p> <pre><code>my_model.FieldOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='F-Output-2', variables=PRESELECT)\nmy_model.HistoryOutputRequest(createStepName='Step-1', frequency=LAST_INCREMENT, name='H-Output-1', variables=PRESELECT)\n</code></pre>"},{"location":"abaqus.html#output-related-settings-in-json-file","title":"Output-related settings in JSON file","text":"<p>The values of the <code>interface_output[\"model_part\"]</code> keys should match the names of the node sets defined in Abaqus, appended with \"_nodes\". These values are internally used in CoCoNuT to distinguish the different <code>ModelParts</code>. The order defined in the <code>interface_output</code> list should be the same as the <code>interface_input</code> list and match the flow solver wrapper counterpart. </p> <pre><code>{\n  \"interface_output\": \n  [\n    {\n      \"model_part\": \"NODESET_NAME_A_nodes\",\n      \"variables\": [\"displacement\"]\n    },\n    {\n      \"model_part\": \"NODESET_NAME_B_nodes\",\n      \"variables\": [\"displacement\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"abaqus.html#note-about-choosing-modelparts","title":"Note about choosing <code>ModelParts</code>","text":"<p>The created \"surfaces\" and \"node sets\" for load input and displacement output respectively, correspond to <code>ModelParts</code> in the CoCoNuT code, a representation of the data used for the coupling. It is strongly advised to sub-divide to fluid-structure interaction interface intelligently, depending on the geometry. As a rule of thumb it can be said that a surfaces at two sides of a sharp corner should be assigned to a different <code>ModelPart</code>. As the interpolation is based on shortest distance, issues can arise at sharp corners. Those are avoided by having different <code>ModelParts</code> at each side of the corner. Another reason to do this is because the code cannot handle elements with two or more faces being part of the same <code>ModelPart</code>. This situation would occur if the surface contains corners. An example is an airfoil where the suction side and pressure side belong to the same <code>ModelPart</code>: elements at the trailing edge will have (a) face(s) at both the pressure side and suction side. Even when the code would allow this, interpolation mistakes become likely, as a geometrical node or load point on the suction side could have a nearest neighbour on the pressure side, causing that the wrong data is used for interpolation.</p>"},{"location":"abaqus.html#log-files","title":"Log files","text":"<p>A general event log of the procedure can be found in the working directory, in a file named <code>abaqus.log</code>. For more detailed information on a certain time step, the .msg file written by Abaqus can be consulted. In CoCoNuT these are structured as follows: <code>CSM_TimeA.msg</code>, <code>A</code> being the time step. Typically multiple coupling iterations are done within each time step, so these .msg-files get overwritten by each new coupling iteration in the same time step.</p>"},{"location":"abaqus.html#restarting-a-calculation","title":"Restarting a calculation","text":"<p>For a restart of a calculation, say at time step <code>B</code>, it is necessary that all the Abaqus simulation files of the previous calculation at time step <code>B</code> are still present. This is in accordance with the <code>save_restart</code> parameter defined in a higher component.  Particulary for the Abaqus solver wrapper, it is important that the files <code>CSM_Time0Cpu0SurfaceAFaces.dat</code>, <code>CSM_Time0SurfaceAElements.dat</code> and <code>CSM_Time0SurfaceANodes.dat</code> are still present from previous calculation. The files <code>CSM_Time0.inp</code> and <code>CSM_Restart.inp</code> will be generated during initialization of the restarted calculation.  This allows the user to alter some parameters in the input file before restart, e.g. altering output requests, boundary conditions or applying additional loads.  Since Abaqus only uses the <code>CSM_Restart.inp</code> (which does not contain any mesh information) and output files of the previous calculation, it is pointless to change the mesh before a restart.</p>"},{"location":"abaqus.html#end-of-the-calculation","title":"End of the calculation","text":"<p>Unlike for other solvers, CoCoNuT does not keep track of the time it takes to write case files. The reason for this is that Abaqus starts and stops every single coupling iteration, see here and therefore needs data files to be saved every time step in order to continue the calculation in a next coupling iteration or time step.  Saving data files is as such seen as inherent to solving the solution step.</p>"},{"location":"abaqus.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The convergence criterion solver coupling convergence can not be used for the Abaqus solver wrapper.</p>"},{"location":"abaqus.html#version-specific-documentation","title":"Version specific documentation","text":""},{"location":"abaqus.html#v2023","title":"v2023","text":"<p>No major changes.</p>"},{"location":"abaqus.html#v2024","title":"v2024","text":"<p>Abaqus is now using Python 3.10 instead of Python 2.7.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html","title":"Breaking dam with Fluent2D and Abaqus2D","text":"<p>This example simulates a dam-break on a top-fixed flexible gate. The liquid, initially located in a free-surface tank, imposes a variable pressure on the bending flexible gate. This case has been examined numerically and experimentally by Antoci et al. [1]. Here, this 2D FSI calculation is performed with Fluent and Abaqus.</p> <p>The figure below shows the bending of the gate and the flowing water (with Fluent). </p> <p>The geometry is provided in the following figure. Pressure outlets and walls are indicated in blue and black, respectively. The gap beneath the gate is exagerated for clarity. </p> <p>The corresponding parameters are:</p> parameter value description <code>A</code> 0.1 m Width of the liquid tank. <code>G</code> 0.0025 m Clearance of the elastic gate. <code>H</code> 0.14 m Initial height of the liquid column. <code>L</code> 0.079 m Height of the elastic gate. <code>S</code> 0.005 m Thickness of the elastic gate. <p>The elastic gate is made of rubber and has the following parameters:</p> <ul> <li>density: 1100 kg/m\u00b3</li> <li>modulus of elasticity: 10^7 Pa</li> <li>poisson's ratio: 0.49</li> </ul> <p>The flow calculation uses the volume of fluid (VOF) method to model the free-surface. The liquid phase is water with the following properties:</p> <ul> <li>density: 1000 kg/m\u00b3</li> <li>dynamic viscosity: 0.001 Pa\\cdots</li> </ul> <p>The gas phase is air modelled with the following parameters:</p> <ul> <li>density: 1.225 kg/m\u00b3</li> <li>dynamic viscosity: 1.7894 10^{-5} Pa\\cdots</li> </ul> <p>The gravitational accelartion is 9.81 m/s\u00b2. The total simulated time is 0.4 s in time steps of 0.001 s.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). The reuse parameter <code>q</code> is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html#solvers","title":"Solvers","text":"<p>Fluent is used as flow solver. The provided mesh is triangular. When the gate bends remeshing is performed to perserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters.</p> <p>The structural solver is Abaqus. The Abaqus case is built when setting up the case starting from the file <code>mesh_breaking_dam.inp</code> containing nodes and elements. This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_breaking_dam.inp</code>. The Abaqus element type used is CPE8R.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.</p>"},{"location":"breaking_dam_fluent2d_abaqus2d.html#references","title":"References","text":"<p>[1] Antoci C., Gallatie M. and Sibilla S., \"Numerical simulation of fluid-structure interaction by SPH\", Computers &amp; Structures, vol. 85, no. 11, pp. 879-890, 2007.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html","title":"Breaking dam with Fluent2D and KratosStructure2D","text":"<p>This example simulates a dam-break on a top-fixed flexible gate. The liquid, initially located in a free-surface tank, imposes a variable pressure on the bending flexible gate. This case has been examined numerically and experimentally by Antoci et al. [1]. Here, this 2D FSI calculation is performed with Fluent and Kratos Multiphysics.</p> <p>For details about geometry, parameters and boundary conditions refer to the example with Fluent and Abaqus.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is IQN-ILSM with reuse of q = 50 time steps. These are used to stabilize and accelerate the convergence.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html#predictor","title":"Predictor","text":"<p>The initial guess at each time step is made using the linear predictor.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm of the displacement is a factor 10^{3} lower than the initial value.</li> </ul> <p>The simulation stops as soon as one of the two criteria is met.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html#solvers","title":"Solvers","text":"<p>Fluent is used as flow solver. The provided mesh is triangular. When the gate bends, remeshing is performed to preserve its quality. A script to regenerate it using Gambit is included. This script allows the resolution and geometric parameters to be changed.</p> <p>The structural solver is Kratos Multiphysics. First-order, quadrilateral, plane strain elements are used.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.</p>"},{"location":"breaking_dam_fluent2d_kratos_structure2d.html#references","title":"References","text":"<p>[1] Antoci C., Gallatie M. and Sibilla S., \"Numerical simulation of fluid-structure interaction by SPH\", Computers &amp; Structures, vol. 85, no. 11, pp. 879-890, 2007.</p>"},{"location":"breaking_dam_openfoam2d_kratos_structure2d.html","title":"Breaking dam with OpenFOAM2D and KratosStructure2D","text":"<p>This example simulates a dam-break on a top-fixed flexible gate. The liquid, initially located in a free-surface tank, imposes a variable pressure on the bending flexible gate. This case has been examined numerically and experimentally by Antoci et al. [1]. Here, this 2D FSI calculation is performed with Fluent and Kratos Multiphysics.</p>"},{"location":"breaking_dam_openfoam2d_kratos_structure2d.html#references","title":"References","text":"<p>[1] Antoci C., Gallatie M. and Sibilla S., \"Numerical simulation of fluid-structure interaction by SPH\", Computers &amp; Structures, vol. 85, no. 11, pp. 879-890, 2007.</p>"},{"location":"convergence_criteria.html","title":"Convergence criteria","text":"<p>Convergence criteria are an essential part of numerical tools. They should be chosen wisely in order to obtain a reasonably accurate solution without performing more iterations than needed. This documentation describes how the user can practically assemble a set of convergence criteria.</p>"},{"location":"convergence_criteria.html#types","title":"Types","text":""},{"location":"convergence_criteria.html#iteration-limit","title":"Iteration limit","text":"<p>The <code>type</code> <code>convergence_criterion.iteration_limit</code> is satisfied if the number of coupling iterations equals or is larger than a predefined maximum.</p> <p>The <code>settings</code> dictionary contains one entry:</p> parameter type description <code>maximum</code> int Maximum number of iterations."},{"location":"convergence_criteria.html#absolute-norm","title":"Absolute norm","text":"<p>The <code>type</code> <code>convergence_criterion.absolute_norm</code> is satisfied if the p-norm of the residual in the last coupling iteration is smaller than a predefined <code>tolerance</code>.  More information on how the residual is calculated can be found in the coupled solvers documentation. The p-norm of the residual r is defined as</p>  \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} ,  <p>where r_i is the i-th component of the residual.</p> <p>The <code>settings</code> are as follows:</p> parameter type description <code>order</code> int Order p of the norm. <code>tolerance</code> double Limit value for convergence."},{"location":"convergence_criteria.html#relative-norm","title":"Relative norm","text":"<p>The <code>type</code> <code>convergence_criterion.relative_norm</code> is completely analogous to the absolute norm. Instead of the norm of  the last residual being smaller than a set <code>tolerance</code>, now the ratio norm of the residual of the last coupling iteration to the  norm of the residual of the first coupling iteration is compared to a <code>tolerance</code>. Zero divisions are avoided internally by comparing the norm of the residual of the first coupling iteration to the machine limit for floating points, i.e. the smallest number different from zero. In case this initial norm is too small, an exception will be raised. Should this happen, it is advised to opt for the absolute norm criterion instead of relative norm.</p> <p>These are the same as for <code>convergence_criterion.absolute_norm</code>.</p>"},{"location":"convergence_criteria.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The <code>type</code> <code>convergence_criterion.solver_coupling_convergence</code> is a convergence criterion that uses the convergence of a solver to determine the convergence of the coupling loop. The criterion is considered fulfilled once the solver converges in its first solver iteration. Not all solvers allow for this feature, see their respective documentation. A detailed explanation of this criterion is found in Spenke and Delaiss\u00e9 et al. [1].</p> <p>Typically, a <code>solver_coupling_convergence</code> criterion is used for each solver, combined with an <code>and</code> criterion (see Combining multiple convergence criteria). This way, the coupling loop is considered converged when all solvers converge in their first solver iteration.</p> <p>The <code>settings</code> dictionary contains one entry:</p> parameter type description <code>solver_index</code> int Index of the solverwrapper in the <code>solver_wrappers</code> list of the coupled solver to which this convergence criterion belongs."},{"location":"convergence_criteria.html#combining-multiple-convergence-criteria","title":"Combining multiple convergence criteria","text":"<p>In most cases, it is wise to combine two criteria: one to ensure a high enough accuracy and an iteration limit in order to break loops that are not converging fast enough. In that case, the criteria are combined via <code>or</code> or <code>and</code> statements. In that case, the <code>type</code> is set to <code>convergence_criterion.or</code> (alternatively, <code>convergence_criterion.and</code>) and the <code>settings</code> contain a <code>criteria_list</code> that contains single criteria in the same way as described above. </p> <p>In the following example, the <code>iteration_limit</code> and <code>relative_norm</code> criteria are combined using an <code>or</code> statement. Note that the number of criteria is not limited to two. Moreover, the <code>or</code> and <code>and</code> statements can be combined multiple times, if needed.</p> <pre><code>{\n  \"type\": \"convergence_criteria.or\",\n  \"settings\": {\n    \"criteria_list\": [\n      {\n        \"type\": \"convergence_criteria.iteration_limit\",\n        \"settings\": {\n          \"maximum\": 20\n        }\n      },\n      {\n        \"type\": \"convergence_criteria.relative_norm\",\n        \"settings\": {\n          \"order\": 2,\n          \"tolerance\": 1e-3\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>An example of the use of the <code>and</code> criterion is with use of the <code>solver_coupling_convergence</code> criterion.</p> <pre><code>{\n  \"type\": \"convergence_criteria.and\",\n  \"settings\": {\n    \"criteria_list\": [\n      {\n        \"type\": \"convergence_criteria.solver_coupling_convergence\",\n        \"settings\": {\n          \"solver_index\": 0\n        }\n      },\n      {\n        \"type\": \"convergence_criteria.solver_coupling_convergence\",\n        \"settings\": {\n          \"solver_index\": 1\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"convergence_criteria.html#dummy-convergence-criterion","title":"Dummy convergence criterion","text":"<p>This dummy convergence criterion can be used in the explicit or one-way coupled solvers, which don't require a convergence criterion.</p> <p>If the use of a dummy convergence criterion is allowed, the <code>type</code> (<code>convergence_criteria.dummy_convergence_criterion</code>) can be written explicitly or omitted. No <code>settings</code> are required. Note that the key <code>convergence_criterion</code> is still required.</p>"},{"location":"convergence_criteria.html#references","title":"References","text":"<p>[1] Spenke T., Delaiss\u00e9 N., Degroote J. and Hosters, N., \"On the number of subproblem iterations per coupling step in partitioned fluid-structure interaction simulations\", International Journal for Numerical Methods in Engineering, vol. 125, no. 7, e7420, 2024.</p>"},{"location":"coupled_solvers.html","title":"Coupled solvers","text":"<p>This documentation describes the different types of coupled solvers which are available. A coupled solver refers to a coupling algorithm used to couple two solvers, typically a flow and a structural solver. Some of these coupled solvers make use of one or more models. An odd one out is <code>test_single_solver</code> which allows to test only one solver by coupling it to a dummy solver.  All coupled solvers inherit from the class <code>CoupledSolver</code>.</p> <p>In the parameter JSON file, the dictionary <code>coupled_solver</code> holds the <code>type</code> and the dictionary <code>settings</code>, but also the dictionary <code>predictor</code>, the dictionary <code>convergence_criterion</code> and the list <code>solver_wrappers</code> containing dictionaries (one for each solver wrapper, typically two). More information on these last three can be found in the predictors, convergence criteria and the solver wrappers documentation, respectively.</p> <p>In the following subsections, explanatory schematics will be shown. In those schematics, \\mathcal{F} is the first solver with input x and output \\widetilde{y} and \\mathcal{S} is the second solver with input y and output \\widetilde{x}. Typically, these solvers are a flow and structural solver, respectively. Note that the column vectors such as x and y typically contain different components of the same variables or even different variables. Often, the vectors x and \\widetilde{x} contain the three components of displacement, whereas the vectors y and \\widetilde{y} contain the pressure and the three components of traction. However, this has no importance for the coupled solver, as long as the in- and outputs of both solvers correspond to each other. Further, the superscript k=0\\dots denotes the iteration, where k+1 is the current iteration. Finally, the difference between the output \\widetilde{x}^k and input x^k in the same iteration is defined as the residual r^k=\\widetilde{x}^k-x^k, which is used to monitor the convergence of the calculation.</p>"},{"location":"coupled_solvers.html#the-class-coupledsolver","title":"The class CoupledSolver","text":"<p>This class is the base class for all coupled solvers. The following parameters need to be included in the <code>settings</code> dictionary. Here they are listed in alphabetical order.</p> parameter type description <code>anonymous</code> bool (optional) Default: <code>false</code>. If <code>true</code>, the data field <code>info</code>, which contains the hostname of the machine, is not saved, see results pickle file. <code>debug</code> bool (optional) Default: <code>false</code>. The data <code>solution_x</code> and <code>solution_y</code> are saved every iteration except of every time step (see results pickle file). Residual distribution is also saved in additional field <code>solution_r</code> for every iteration. <code>delta_t</code> float Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. <code>case_name</code> str (optional) Default: <code>\"case\"</code>. Name of the case. This name is used to store a pickle file with results (<code>&lt;case_name&gt;_results.pickle</code>) and a restart file (<code>&lt;case_name&gt;_restart_ts&lt;time_step&gt;.pickle</code>). If a files already exists, it is overwritten with the exception of the results file upon restart. In that case the new data is appended. <code>restart_case</code> str (optional) Default: <code>case_name</code>. Only used when restart is performed (<code>timestep_start</code> &gt; 0). Refers to the case which has to be restarted. The following pickle file will be used: <code>&lt;restart_case&gt;_restart_ts&lt;timestep_start&gt;.pickle</code>. This file path starts in the folder from where the simulation is performed. <code>save_restart</code> int (optional) Default: <code>-1</code>. Indicates the time step interval at which a restart pickle file has to be saved. A minus sign indicates only the file from the last interval is retained. A save of restart information also triggers a results save, if <code>save_results</code> is non-zero. <code>save_results</code> int (optional) Default: <code>0</code>. Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If <code>0</code>, no such information is stored and no pickle file is written. <code>time_step_start</code> int Time step number to (re)start a transient FSI calculation. If <code>0</code> is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver wrapper implements restart, see the corresponding documentation for more information. For a steady simulation, the value should be <code>0</code>. <p><code>timestep_start</code> and <code>delta_t</code> are necessary parameters (also in a steady simulation), but can also be defined in the solver wrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed.</p> <p>These parameters should also be specified for the coupled solvers inheriting from <code>CoupledSolver</code>.</p>"},{"location":"coupled_solvers.html#gauss-seidel","title":"Gauss-Seidel","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.gauss_seidel</code>.</p> <p>Gauss-Seidel or fixed-point iterations are the simplest way of coupling two solvers: the output of one solver is given to the other one without adjustment.</p> <p>The following figure shows the basic methodology.</p> <p></p> <p>Gauss-Seidel iterations are very simple, but unstable for cases with incompressible flow and high added-mass. A considerable convergence stabilization and acceleration is obtained by modifying the input to one or both of the solvers using derivative information, as will be shown further.</p> <p>No additional settings are required, besides those for the class <code>CoupledSolver</code>.</p>"},{"location":"coupled_solvers.html#relaxation","title":"Relaxation","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.relaxation</code>.</p> <p>Gauss-Seidel iterations are very simple, but are unstable for cases with incompressible flow and high added-mass. A simple approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\widetilde{x}^k=x^k+\\omega r^k $$ with x^k and \\widetilde{x}^k, respectively the input for the first solver and the output of the second solver in iteration k. The difference between both is called the residual r^k=\\widetilde{x}^k-x^k. The mixing or relaxation factor is \\omega.</p> <p>A symbolic schematic is given in the following figure.</p> <p></p> <p>This method is again quite simple, but able to stabilize some cases that fail with Gauss-Seidel iterations. One can see that a lower \\omega corresponds to a larger portion of the previous solution to be used. This increases stability, but decreases convergence speed. For more challenging problems, with incompressible flow and high added-mass, this approach will result in a very slow convergence, if it converges at all.</p> <p>Beside the parameters required in the class <code>CoupledSolver</code>, the following parameter needs to be included in the <code>settings</code> dictionary.</p> parameter type description <code>omega</code> float Relaxation factor."},{"location":"coupled_solvers.html#aitken","title":"Aitken","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.aitken</code>.</p> <p>Gauss-Seidel iterations are very simple, but are unstable for many cases. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult: a high factor leads to a higher degree of stability, but a lower convergence speed. In more challenging cases there will be no acceptable value for \\omega. In this coupling method a dynamic relaxation factor is used. The output of the first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\widetilde{x}^k=x^k+\\omega^k r^k $$ with x^k and \\widetilde{x}^k, respectively the input for the first solver and the output of the second solver in iteration k. The difference between both is called the residual r^k=\\widetilde{x}^k-x^k. The mixing or relaxation factor is \\omega^k is dynamic in the sense that its value changes between iterations.</p> <p>A symbolic schematic is given in the following figure.</p> <p></p> <p>The value of \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$</p> <p>The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n, but limited to \\omega^{max}. $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max}.</p> <p>This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods, which can be interpreted as using different relaxation factors for different Fourier modes of the output of the second solver.</p> <p>Beside the parameters required in the class <code>CoupledSolver</code>, the following parameter needs to be included in the <code>settings</code> dictionary.</p> parameter type description <code>omega_max</code> float Maximal relaxation factor."},{"location":"coupled_solvers.html#iqni","title":"IQNI","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.iqni</code>.</p> <p>The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian. In this type of coupling algorithm, the combination of the two solvers is seen as one system. The input of the first solver \\mathcal{F} in iteration k is denoted by x^k. The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\widetilde{x}^k. The difference between output and input is called the residual r^k=\\widetilde{x}^k-x^k.</p> <p>A residual operator \\mathcal{R}(x) is defined, which returns the residual r^k as a function of x^k. The goal is to find x for which \\mathcal{R}(x)=0, i.e. the root. This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r, $$ where \\mathcal{R}' is the Jacobian of \\mathcal{R} with respect to x, \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations  and \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. The iteration update can also be written as $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k. $$</p> <p>However, this Jacobian is not accessible and therefore has to be approximated. Instead of approximating \\mathcal{R}', solving the linear system can be avoided by approximating its inverse directly.</p> <p>The approximation procedure typically results in a low-rank Jacobian. Whereas, a full rank Jacobian is required for the Newton-Raphson update to function properly. Therefore, the inverse Jacobian of an altered residual operator \\widetilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\widetilde{\\mathcal{R}}(\\widetilde{x}^{k+1})=\\mathcal{R}(\\widetilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\widetilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\widetilde{\\mathcal{R}}' is the Jacobian of \\widetilde{\\mathcal{R}} with respect to \\widetilde{x} and I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\widetilde{x}^k=\\widetilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k, $$ where \\Delta\\widetilde{x}^k=\\widetilde{x}^{k+1}-\\widetilde{x}^k is the difference between the output of two subsequent iterations. This Jacobian is also not known, but is approximated using a <code>model</code> and denoted by \\widetilde{N}^k. The type of <code>model</code> and its settings are specified in the <code>settings</code> dictionary. This model returns an estimation of \\Delta\\widetilde{x}^k given a value \\Delta r^k=-r^k $$ \\Delta\\widetilde{x}^k=\\widetilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\widetilde{N}^k-I)\\Delta r^k=x^k-\\widetilde{N}^k r^k+r^k. $$</p> <p>A symbolic schematic is given in the following figure.</p> <p></p> <p>For more information with respect to the approximation of the Jacobian, refer to the models' documentation. More information about residual operator methods can be found in [1, 3].</p> <p>Beside the parameters required in the class <code>CoupledSolver</code>, the following parameters need to be included in the <code>settings</code> dictionary. They are listed in alphabetical order.</p> parameter type description <code>model</code> dict Model component. <code>omega</code> float Relaxation factor."},{"location":"coupled_solvers.html#ibqn","title":"IBQN","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.ibqn</code>.</p> <p>The abbreviation IBQN refers to interface block quasi-Newton. In type of coupling iteration, the system  $$ \\begin{cases}     \\mathcal{F}(x)-y=0     \\newline     \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Again, \\mathcal{F} is the first solver with input x and output \\widetilde{y} and \\mathcal{S} is the second solver with input y and output \\widetilde{x}. In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$     \\begin{bmatrix}         \\mathcal{F}'(x) &amp; -I         \\newline         -I &amp;   \\mathcal{S}'(y)     \\end{bmatrix}     \\begin{bmatrix}         \\Delta x         \\newline         \\Delta y     \\end{bmatrix}     =-     \\begin{bmatrix}         \\mathcal{F}(x)-y         \\newline         \\mathcal{S}(y)-x     \\end{bmatrix}, $$ where \\mathcal{F}' and \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are, however, not accessible and are approximated using a <code>model</code> as specified in the <code>settings</code> dictionary. To the first and second solver correspond <code>model_f</code>, denoted here by M_f, and <code>model_s</code>, denoted bye M_s, respectively. For example, <code>model_f</code> returns an estimation of \\Delta\\widetilde{y}^k=\\widetilde{y}^{k+1}-\\widetilde{y}^k given \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\widetilde{y}^k=M_f^k \\Delta x^k. $$</p> <p>Solving for x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\widetilde{x}^k-x^k+M_s^k(\\widetilde{y}^k-y^k) $$ for \\Delta x^k. This is done matrix-free using the Generalized minimal residual method (GMRES). Analogously, the input y^{k+1}=y^k+\\Delta y^k for the structural solver by solving  $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\widetilde{y}^{k+1}-y^k+M_f^{k+1}(\\widetilde{x}^k-x^{k+1}) $$ for \\Delta y^k.</p> <p>A symbolic schematic is given in the following figure.</p> <p></p> <p>The actual approximation of the Jacobian occurs with the same models as before. More information about block methods can be found in [1].</p> <p>Beside the parameters required in the class <code>CoupledSolver</code>, the following parameters need to be included in the <code>settings</code> dictionary. They are listed in alphabetical order.</p> parameter type description <code>absolute_tolerance_gmres</code> float Absolute tolerance used in the GMRES method. <code>model_f</code> dict Model component corresponding to the first solver wrapper. <code>model_s</code> dict Model component corresponding to the second solver wrapper. <code>omega</code> float Relaxation factor. <code>relative_tolerance_gmres</code> float Relative tolerance used in the GMRES method."},{"location":"coupled_solvers.html#iqnism","title":"IQNISM","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.iqnism</code>. This coupled solver is linked to the IQN-ILSM framework [2, 3].</p> <p>The abbreviation IQNISM refers to interface quasi-Newton with inverse Jacobian from surrogate model. This coupled solver belongs in the same category as the IQNI coupled solver: the combination of the two solvers is seen as one system, where the input of the first solver is transferred unchanged to the second solver. The difference between output and input of this system is called the residual r^k=\\widetilde{x}^k-x^k.</p> <p>Just like for IQNI, a residual operator \\mathcal{R}(x) is defined and the root of this system of non-linear equations is solved using Newton-Raphson iterations, as follows $$ x^{k+1}=x^k-\\widetilde{N}^k r^k+r^k, $$ where \\widetilde{N}^k is an approximation of the inverse Jacobian of \\mathcal{R} with respect to \\widetilde{x}.</p> <p>As in IQNI, this approximation is obtained using the <code>model</code> components. Only here, two of them ar used: a <code>surrogate</code> model is used, in addition to a secant model. The type of the models and their settings are specified in the <code>settings</code> dictionary: The key of the surrogate model is <code>surrogate</code>, the key of the secant model is simply <code>model</code>. Both of them are required. However, a dummy model can be used to disable one of them. It is not recommended to disable the secant model (key <code>model</code>), as this model provides a Jacobian which is based on the actual problem.</p> <p>The <code>surrogate</code> model solves a surrogate coupling problem at the start of every time step. The solution of this surrogate problem can be used as prediction (see surrogate predictor) and its Jacobian can be used here. More information with respect to this type of model can be found in the models' documentation. If only the solution is to be used, the parameter <code>surrogate_modes</code> has to be set to <code>0</code>. This parameter denotes the number of modes from the surrogate Jacobian that should be used (starting from the first determined mode(s)). Whether the surrogate solution is used for prediction, is determined by the <code>predictor</code> settings of the coupled solver. If the surrogate model does not provide a surrogate solution (only a surrogate Jacobian), surogate prediction is not possible.</p> <p>The two models are combined as follows. The secant model is used as before, but, as the secant Jacobian is defective (not full-rank), part of the residual is not treated by this Jacobian. For the modes corresponding to the part of the residual, not covered by the secant Jacobian, the surrogate Jacobian is used. Note that, in this way, the secant Jacobian has preference over the surrogate Jacobian.</p> <p>If the coupled solver in the surrogate model uses IQNISM as well, a nested surrogate construction is created, where for the part of residual not treated by the first surrogate Jacobian the second surrogate is used.</p> <p>Next to the parameters required in the class <code>CoupledSolver</code>, the following parameters need to be included in the <code>settings</code> dictionary. They are listed in alphabetical order.</p> parameter type description <code>model</code> dict Model component. <code>omega</code> float (optional) Default: <code>1</code>. Relaxation factor for when the modes not covered by the surrogate model, when the secant model is not yet active. <code>surrogate</code> dict Surrogate component. <code>surrogate_modes</code> int (optional) Default: all modes. The number of modes from the surrogate Jacobian that should be used in the Jacobian approximation (starting from the first determined surrogate mode(s)). <code>surrogate_synchronize</code> bool (optional) Default: <code>true</code>. Whether or not the surrogate model is synchronized at the end of the time step (only if the surrogate offers this capability). <p>This coupled solver is closely related to the IQN-ILSM framework described in [2]. The settings structure for the different surrogate models discussed in this work are:</p> previous time steps (e.g. 50) (=reuse)other surrogate modelprevious time steps + other surrogate model <pre><code>{\n  \"type\": \"coupled_solvers.iqnism\",\n  \"settings\": {\n    \"omega\": 0.01,\n    \"model\": {\n      \"type\": \"coupled_solvers.models.mvmf\",\n      \"settings\": {\n        \"q\": 50\n      }\n    },\n    \"surrogate\": {\n      \"type\": \"coupled_solvers.models.dummy_model\"\n    },\n    ...\n  },\n  ...\n}\n</code></pre> <pre><code>{\n  \"type\": \"coupled_solvers.iqnism\",\n  \"settings\": {\n    \"model\": {\n      \"type\": \"coupled_solvers.models.mvmf\",\n      \"settings\": {\n        \"q\": 0\n      }\n    },\n    \"surrogate\": {\n      \"type\": \"coupled_solvers.models.surrogate\",\n      \"settings\": {\n        ...\n      }\n    },\n    ...\n  },\n  ...\n}\n</code></pre> <pre><code>{\n  \"type\": \"coupled_solvers.iqnism\",\n  \"settings\": {\n    \"model\": {\n      \"type\": \"coupled_solvers.models.mvmf\",\n      \"settings\": {\n        \"q\": 50\n      }\n    },\n    \"surrogate\": {\n      \"type\": \"coupled_solvers.models.surrogate\",\n      \"settings\": {\n        ...\n      }\n    },\n    ...\n  },\n  ...\n}\n</code></pre>"},{"location":"coupled_solvers.html#explicit","title":"Explicit","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.explicit</code>.</p> <p>In contrast to the coupled solvers presented above, which implement strongly coupled or implicit techniques, the explicit coupled solver does not iterate between the solvers within a time step. Instead, the solvers are only evaluated once per time step. Therefore, equilibrium between fluid and structure is not exactly satisfied.  This technique is suitable for problems with low added mass, such as aeroelastic problems. For problems with high added mass, they will fail due to stability issues.</p> <p>No additional parameters are required besides the parameters required in the class <code>CoupledSolver</code>. For this coupled solver, the <code>convergence_criteria</code> are ignored. The key <code>convergence_criteria</code> is still required, but it may remain empty.</p>"},{"location":"coupled_solvers.html#one-way","title":"One-way","text":"<p>The <code>type</code> for this coupled solver is <code>coupled_solvers.one_way</code>.</p> <p>In the one-way coupled solver the fluid forces are coupled to the structural model without feedback of the structural deformation to the fluid solver. This coupled solver can be used when the structural deformation due to the fluid forces may be neglected.</p> <p>No additional parameters are required besides the parameters required in the class <code>CoupledSolver</code>. For this coupled solver, the <code>convergence_criteria</code> and <code>preditors</code> are ignored. The keys <code>convergence_criteria</code> and <code>predictors</code> are still required, but they may remain empty.</p>"},{"location":"coupled_solvers.html#test-single-solver","title":"Test single solver","text":"<p>The solver <code>test_single_solver</code> can be used to test new cases and solver settings. The idea behind this component is to only test one of the two solvers, while the other one is replaced by a dummy. This test environment inherits from the class <code>CoupledSolver</code>. The <code>type</code> for this coupled solver is <code>coupled_solvers.test_single_solver</code>.</p>"},{"location":"coupled_solvers.html#dummy-solver","title":"Dummy solver","text":"<p>To test only one solver, a dummy solver must be used. Such a dummy solver is implemented by a test class in the file <code>dummy_solver.py</code>. Its path starts in the folder from where the simulation is performed, e.g. the same folder level as <code>run_simulation.py</code>. Upon run-time an instance of this class is made. The test class can be setup in two ways (in order of priority):</p> <ol> <li>Using a method named <code>get_input(interface_input_to, n)</code>, which sets the given <code>interface</code> to the desired value. This can, for example, be done using a pickle file from a previous calculation.</li> <li>Using methods of the form <code>calculate_&lt;variable&gt;(x, y, z, n)</code>, with <code>&lt;variable&gt;</code> being a variable required by the tested solver, e.g. <code>displacement</code>, <code>pressure</code> or <code>traction</code>. The coordinates are the coordinates of the data location in the undeformed state and <code>n</code> is the time step. How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.</li> </ol> <p>Optionally, the test class can also have an <code>initialize(interface_input_to, solver_index)</code> method. If so, it will be called at the start of the simulation, with as <code>interface_input_to</code> the input <code>interface</code> of the tested solver. This is especially useful when the first approach is followed. Some clarifying examples are given in the example test_single_solver. The test class name is provided in the JSON settings as a string. If no test class is provided or the value <code>None</code> is used, zero input will be used.</p> <p>The JSON file requirements for the class <code>CoupledSolverTestSingleSolver</code> are different from the other coupled solvers in the sense that they only require the <code>type</code>, which is <code>coupled_solvers.test_single_solver</code>, the dictionary <code>test_settings</code> and the list <code>solver_wrappers</code> containing at least one solver wrapper. The keys for the <code>test_settings</code> dictionary are listed in alphabetical order below.</p> parameter type description <code>debug</code> bool (optional) Default: <code>false</code>. Residual distribution is also saved in additional field <code>solution_r</code> for every iteration (see results pickle file). <code>delta_t</code> float (optional) Time step size to be used in the test. Is optional as long as this value is defined in the <code>settings</code> dictionary. If a different value is defined in both dictionaries, the one defined in <code>test_settings</code> is chosen. <code>case_name</code> str (optional) Name of the case used to store a pickle file with results. The pickle file will have the name <code>&lt;case_name&gt;_&lt;test_solver_working_directory&gt;_results.pickle</code>. If not provided, the value from <code>settings</code> is used or if <code>settings</code> is not present: <code>\"case\"</code>. <code>save_results</code> int (optional) Default: <code>0</code>. Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If <code>0</code>, no such information is stored and no pickle file is written. If not provided, the value from <code>settings</code> is used or if <code>settings</code> is not present: <code>0</code>. <code>solver_index</code> int Has a value <code>0</code> or <code>1</code> and indicates the solver that one wants to test. <code>0</code> indicates the first solver wrapper that appears in the JSON-file, <code>1</code> the second one. <code>test_class</code> str (optional) Refers to the class to use in the <code>dummy_solver.py</code>. If not provided or <code>null</code>, zero input will be used. <code>timestep_start</code> int (optional) Time step to start from. If not provided the value defined in the <code>settings</code> dictionary is used. If the <code>settings</code> dictionary is not present, zero is used. <p>Other dictionaries, used for the actual calculation can be kept, but will not be used, with the possible exception of the <code>settings</code> dictionary. The <code>settings</code> dictionary is used to look up <code>delta_t</code>, <code>timestep_start</code>, <code>save_results</code> and <code>case_name</code> if not provided in <code>test_settings</code>. Note that <code>test_settings</code> has priority over the parameters defined in <code>settings</code>. This means a calculation can be tested, by only adding the <code>test_settings</code> dictionary and changing the coupled solver <code>type</code> to <code>coupled_solvers.test_single_solver</code> and without altering anything else. An illustration can be found in the example test_single_solver.</p> <p>The optional pickle file, which saves some results, uses the name as specified by the JSON settings followed by an underscore and the solver working directory.</p> <p>During run time, the norm of x and y are printed. A residual does not exist here. The arrays x and y do not necessarily have a physical meaning, but are the in- and output of the first solver, which is typically the flow solver. Then, the vector y will contain pressure and traction components for all points. Nonetheless, these values can be useful to verify that the solver wrapper runs.</p> <p>The test environment <code>test_single_solver</code> tests only the <code>solver_wrapper</code> itself, no mapping is included.</p>"},{"location":"coupled_solvers.html#save-results","title":"Save results","text":"<p>In each coupled solver, a positive non-zero value can be assigned to the <code>save_results</code> parameter, in order to save some results into a pickle file. The key <code>case_name</code> dictates the name of this file as explained above. The pickle file is written corresponding to the time step interval as dictated by <code>save_results</code>, but contains information for all time steps. In other words, if the parameter is non-zero, it only controls the writing frequency and not the content of the file. If <code>save_results</code> is zero, no result are kept and no file is written. For a non-zero value of <code>save_restart</code>, a save for restart purposes also triggers the saving of the results file. The pickle file may be used by the postprocessing files included with the examples. It contains a dictionary with the following keys:</p> key value type description <code>solution_x</code> numpy array Contains the values of the vector x (typically displacement) for every time step as columns of a 2 dimensional np-array. The initial value is included as well, such that the number of column will be one higher than the number of calculated time steps. The vector x refers to the input of the first solver wrapper. <code>solution_y</code> numpy array Contains the values of the vector y (typically pressure and traction) for every time step as columns of a 2 dimensional np-array, similar to <code>solution_x</code>. The vector y refers to the input of the second solver wrapper. <code>interface_x</code> interface Interface object used as input for the first solver wrapper. <code>interface_y</code> interface Interface object used as input for the second solver wrapper. <code>iterations</code> list Contains the performed number of coupling iterations for every time step. <code>residual</code> list Nested list, which contains for each time step a list, on its turn containing residuals, one for every iteration of that time step. <code>run_time</code> float Equals the total computation time, i.e. the time between initialization and finalization (excluding initialization). <code>time_allocation</code> dict Dictionary containing a detailed overview of the time spent in the different components for the current simulation. Upon restart, the time allocation of previous runs are stored in sequence under the key <code>previous_calculations</code>. <code>delta_t</code> float Equals the used time step size. <code>timestep_start</code> int Equals the used start time step. <code>case_name</code> str Name of the case. <code>info</code> str Additional info, such as date, restart history and hostname of machine on which simulation is run. Can be disabled using the optional parameter <code>anonymous</code>. <p>In simulations with a large number of points on the interface and a very large number of time steps, this file might take up a larger amount of storage.</p> <p>Finally, there is also a debug option, which can be activated by setting the boolean <code>self.debug</code> on <code>true</code> in the code file itself. Then, the above information is stored every iteration. Additionally, the residual vector is saved as well using the key <code>solution_r</code>, analogously to <code>solution_x</code> and <code>solution_y</code>. Note, however, that the pickle file can be become very large in that case. This option is only meant for debugging a new coupling algorithm. It should not be used in combination with restart.</p>"},{"location":"coupled_solvers.html#restart","title":"Restart","text":"<p>The restart functionality is very useful to continue a calculation which has been stopped, either intentionally or unintentionally. The goal is to continue as if the code had never been interrupted.</p> <p>In order to restart from time step n, the coupled solver instructs the predictor and possibly one or more models to save the necessary data in the state at the end of time step n in a pickle file. By saving the predictor, the initial guess at the start of the first time step(s) will be the same, as the predictor typically extrapolates the solution from the previous time step(s) in some way. The model(s) are saved such that the behavior of the coupling algorithm is the same. This is only important if the model behavior depends on data from previous time steps, e.g. models with reuse (q&gt;0).</p> <p>Besides restarting the exact same simulation, it could be useful to change the settings from the coupled solver or occasional model(s) when restarting. This is possible, refer to the models documentation for more details. Changing the type of coupled solver or occasional model is also possible, but no information will be transferred between the different types, meaning that for example all information from previous time steps is lost.</p> <p>For the predictors the same is true, except for the extrapolators for which there is information transfer. See the documentation of the predictors for more details.</p> <p>The following table gives an overview of the coupled solvers which save one or more additional components or values.</p> type additional components saved for restart <code>coupled_solvers.aitken</code> <code>omega</code> <code>coupled_solvers.iqni</code> <code>model</code> <code>coupled_solvers.ibqn</code> <code>model_f</code> and <code>model_s</code> <code>coupled_solvers.iqnism</code> <code>model</code> and <code>surrogate</code> <p>However, not only the predictor and coupling algorithm depend on previous time steps; this is typically also the case for the solvers. Therefore, it is the responsibility of the solver wrappers, to set up the solvers correctly for restart: they need to ensure that the variables in the whole computational domain are set to the value of time step n. Moreover, its vital that they reconstruct the exact same model parts as in the initial calculation. In other words, the undeformed coordinates must be the same. Conversely, they are not required to initialize the interfaces with the correct data from time step n, as this taken care of by the predictor in the coupled solver. Only when both solver wrappers allow restart, is it possible to restart a calculation!</p>"},{"location":"coupled_solvers.html#saving-restart-files","title":"Saving restart files","text":"<p>During a calculation it is possible to save restart pickle files. As described above the pickle file for restart has a name (<code>&lt;case_name&gt;_restart_ts&lt;time_step&gt;.pickle</code>), based on the setting <code>case_name</code>.</p> <p>The frequency of saving a restart pickle file is determined by the <code>save_restart</code> interval as described above. Remark that it is only useful to save the restart pickle file, when the solver data are saved as well. Therefore, the <code>save_restart</code> parameter is transferred automatically to the solver wrappers.</p> <p>If <code>save_results</code> is non-zero, a save of restart information also triggers the saving of the results pickle file, to avoid discontinuity of this file.</p>"},{"location":"coupled_solvers.html#performing-restart","title":"Performing restart","text":"<p>To restart a case, <code>timestep_start</code> has to be a positive integer above zero. The first time step that will be calculated is <code>timestep_start</code> plus one. The methodology described above does not allow to change any settings of the predictor or model(s), nor the type of coupled solver. Upon restart, this condition is checked, as well as the presence of the pickle file for restart. This file is identified by the setting <code>restart_case</code> as <code>&lt;restart_case&gt;_restart_ts&lt;timestep_start&gt;.pickle</code>. Additionally, it is checked that the new model parts are exactly the same as the previous ones.</p> <p>It is important to realize that the pickle file only makes sure that the initial guess and coupling algorithm work as before. The physical effect of previous time steps dealt with by the solver wrappers. Therefore, in order to be able to perform a restart, the solver files for the corresponding time step also need to be present!</p> <p>When performing restart, the new data will be neatly appended to the already existing results pickle file, leaving out existing time step data after the new time step start. As a result, the results pickle file looks exactly as if the calculation was never stopped, except the fields <code>run_time</code>, <code>time_allocation</code> and <code>info</code>. The latter provides a very short log of when restart is performed.</p> <p>If the results pickle file would not be found for any reason, the user is informed and a new one is made, with the correct <code>timestep_start</code>. Note that the presence of the restart pickle file on the other hand is required. If the <code>case_name</code> is changed, the restart can still be performed by providing the case name for restart using <code>restart_case</code> (see explanation above).</p>"},{"location":"coupled_solvers.html#references","title":"References","text":"<p>[1] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.</p> <p>[2] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Surrogate-based acceleration of quasi-Newton techniques for fluid-structure interaction simulations\", Computers &amp; Structures, vol. 260, pp. 106720, 2022.</p> <p>[3] Delaiss\u00e9 N., Demeester T., Haelterman R. and Degroote J., \"Quasi-Newton methods for partitioned simulation of fluid-structure interaction reviewed in the generalized Broyden framework\", Archives of Computational Methods in Engineering, vol. 30, pp. 3271-3300, 2023.</p>"},{"location":"coupling_components.html","title":"Coupling components","text":"<p>The coupling components are the basic building blocks of the CoCoNuT coupling tool. They are defined in the subdirectories of the <code>coconut/coupling_components</code> directory. There are five types: </p> <ul> <li>Convergence criteria which determine when the calculation has converged within a time step. Subdirectory: <code>convergence_criteria</code>.</li> <li>Coupled solvers (completed by Models, subdirectory <code>coupled_solvers/models</code>) which perform the actual coupling, implementing a coupling algorithm. Subdirectory: <code>coupled_solvers</code>.</li> <li>Mappers which map from one interface discretization to another, i.e. interpolation between non-conformal meshes. Subdirectory: <code>mappers</code>.</li> <li>Predictors which provide an initial guess at the start of a new time step. Subdirectory: <code>predictors</code>.</li> <li>Solver wrappers which provide communication which the actual solvers. Subdirectory: <code>solver_wrappers</code>.</li> </ul> <p>The idea behind these components is modularity. For example, changing a solver wrapper or creating a new one can be done without having to adapt any other components. This allows for high degree of flexibility, a short learning curve and a limited development effort. Moreover, components can be used multiple times without the need for copying code. Detailed information on these components can be found in the specific documentation.</p> <p>All these coupling components inherit from a same superclass called <code>Component</code>, defined in <code>coconut/coupling_components/component.py</code>.  In this class some methods are implemented, which control the flow within CoCoNuT.  For every coupling component, there are <code>initialize</code> and <code>finalize</code>, which are called at the start and end of a calculation, as well as <code>initialize_solution_step</code>, called at the start of each time step, and <code>finalize_solution_step</code> and <code>output_solution_step</code>, both called at the end of each time step. If needed these methods are overwritten to perform a specific action. For example in the <code>finalize</code> method of a <code>solver_wrapper</code>, the termination of the solver software could be implemented.</p> <p>A schematic of the relation between the coupling components for a basic calculation is given in the following figure.</p> <p></p> <p>These coupling components have to communicate with each other. This is done through the use of interfaces, indicated with arrows on the figure.  For these <code>Interface</code> objects (implemented in <code>coconut/data_structure/interfaces.py</code>) containing the (discretized) solution data on the FSI-interface and references to, among others, the coordinates of the discretized interface. The implementation of this <code>Interface</code> class is explained in more detail in the documentation about the data structure.</p>"},{"location":"coupling_components.html#start-of-the-calculation","title":"Start of the calculation","text":"<p>The main coupling component in which all other coupling components are instantiated is the coupled solver. The coupled solver itself is created in the <code>Analysis</code> class (<code>coconut/analysis.py</code>), which is the starting point of the CoCoNuT calculation. Upon the start of CoCoNuT, an instance of <code>Analysis</code> is made and its method <code>run</code> is executed. The coupled solver keeps track of all <code>Components</code> and runs the methods <code>initialize</code>, <code>finalize</code>, <code>initialize_solution_step</code>, <code>finalize_solution_step</code> and <code>output_solution_step</code>, when its respective methods are executed.</p>"},{"location":"coupling_components.html#end-of-the-calculation","title":"End of the calculation","text":"<p>At the end of the calculation a summary will be printed by the coupled solver. Next to the average number of coupling iterations per time step required to reach convergence, it provides an overview of the computational time. The total calculation time is split in the time required for initialization and the actual run time. For both, the distribution over the different components is reported as well, for example, the run time of a <code>solver_wrapper</code> is the time spend in the <code>solve_solution_step</code> method. The part of the run time required for saving data is shown separately, and once more the distribution over the different components are shown. This so-called save time is the time spend in the method <code>output_solution_step</code>. This information allows to assess which part of the calculation is taking the most time and shows how to potentially reduce the calculation time.</p>"},{"location":"coupling_components.html#tools","title":"Tools","text":"<p>Some code to perform specific tasks, like printing with a certain layout or performing a time measurement is useful throughout the code. These functionalities are grouped in the file <code>coconut/tools.py</code>. It suffices to import the file to make use of its functions.</p>"},{"location":"data_structure.html","title":"Data structure","text":"<p>The data structure in CoCoNuT contains different classes that serve as  containers of various types of data that are transferred between the  components of CoCoNuT during the partitioned coupling. It consists of  the following three classes:</p> <ul> <li><code>Model</code></li> <li><code>ModelPart</code></li> <li><code>Interface</code></li> </ul>"},{"location":"data_structure.html#model","title":"Model","text":"<p><code>Model</code> is simply a <code>dict</code> with keys as model part names and values as the  reference to model parts. It serves as a container of instances of  <code>ModelParts</code>. Additionally, it has one important method called  <code>create_model_part</code>, which as the name suggests, creates an instance of the  class <code>ModelPart</code> and adds it to the dictionary.</p>"},{"location":"data_structure.html#modelpart","title":"ModelPart","text":"<p><code>ModelPart</code> is a container of boundary points, that are involved in the  partitioned coupling. This contains the initial coordinates-  <code>x0</code>, <code>y0</code>, <code>z0</code> (<code>1D numpy float array</code>), and point ids-<code>id</code>  (<code>1D numpy int array</code>). It is recommended to always instantiate <code>ModelPart</code>  using the <code>create_model_part</code> method of the class <code>Model</code>, discussed above.  Naturally, the size of <code>x0</code>, <code>y0</code>, <code>z0</code>, and  <code>id</code> should be equal, which is  checked in the <code>__init__</code> method.</p> <p>NOTE: The data in <code>ModelPart</code> once created, either by <code>__init__</code> method of  the <code>ModelPart</code> class or by <code>create_model_part</code> method of the <code>Model</code> class,  cannot be changed later. This is because the initial coordinates of boundary  points are always supplied from the solver wrapper, and they don't change during the various stages of the coupling process. </p>"},{"location":"data_structure.html#interface","title":"Interface","text":"<p><code>Interface</code> stores the <code>variable</code> data that are transferred between the  different components (<code>coupling_components</code>) of CoCoNuT to perform partitioned  coupling. Additionally, it contains a reference to an instance of <code>Model</code>,   usually created in the solver wrapper. As described above, the <code>Model</code> contains  several model parts corresponding to the boundaries in the solver wrappers.  Therefore, in a way, the interface also contains coordinates of the boundary  points that are involved in the coupling. </p> <p>The data in the interfaces are stored as <code>numpy arrays</code> in a nested <code>dict</code>.  The following schematic illustrates the data structure in the  <code>Interface</code> class, where the arrow points from a key to the value in the  <code>dict</code>: </p> <p>For example, in the schematic above, the interface has a model part named  \"mp_1_name\", which has several variable data. The data for the variable <code>var_1</code> is stored in a <code>numpy array</code> with the number of rows equal to the number points in the model part and the number of columns equal to the number of components/dimensions of the variable. The number of dimensions for a variable  is defined in the <code>variable_dimensions</code> <code>dict</code> in the file  <code>data_structure/variables.py</code> variables.py, for example, the number of dimensions for the variables  <code>pressure</code> and <code>displacement</code> is 1 and 3, respectively.</p> <p>The nested <code>dict</code> in the <code>Interface</code> is constructed during the instantiation of the class using a parameters <code>dict</code> given as an input argument. For the schematic shown above, the parameters dict would be:</p> <pre><code>[\n  {\n    \"model_part\": \"mp_1_name\",\n    \"variables\": [\n      \"var_1\",\n      \"var_2\",\n      ..\n    ]\n  },\n  {\n    \"model_part\": \"mp_2_name\",\n    \"variables\": [\n      \"var_3\",\n      ..\n    ]\n  },\n  .\n  .\n  .\n]\n</code></pre> <p>The data in the interface can be accessed, added, or replaced by the various  methods implemented in the <code>Interface</code> class, which can be looked in the file  <code>data_structure/interface.py</code>.</p> <p>NOTE: The file <code>data_structure/variables.py</code> does not contain a class definition.  It has a <code>dict</code> called <code>variable_dimensions</code> with keys as data  variable names (<code>string</code>) and values as the number of components or dimensions  (<code>int</code>). One important point to note is that only variables defined in this  dictionary can be used in CoCoNuT. To use a new variable, the user first  needs to add the variable name and its number of components in this <code>dict</code>.</p>"},{"location":"docs.html","title":"Documentation","text":"<p>This website is a collection of all MarkDown (MD) files found in the <code>coconut</code> package. These files are converted to a static website using MkDocs, based on the outline defined in the <code>mkdocs.yml</code> file.</p>"},{"location":"docs.html#documentation-in-markdown","title":"Documentation in MarkDown","text":"<p>MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this MarkDown tutorial. Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM), which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. </p> <p>The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs. This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). </p> <p>An important rule for writing MD files for this documentation website is that the name of the file must be unique: use names like <code>fluent.md</code> or <code>examples.md</code>, not <code>readme.md</code>.</p>"},{"location":"docs.html#links-to-other-markdown-files","title":"Links to other MarkDown files","text":"<p>It is possible to use relative links to other MarkDown files in CoCoNuT, using the syntax <pre><code>[link description](https://pyfsi.github.io/coconut/mappers)\n</code></pre> where <code>relative_path</code> is the relative path to another MarkDown file, e.g. <code>../coupling_components/mappers/mappers.md</code>. </p> <p>These links can be used in rendered MarkDown, e.g. in PyCharm, but also on GitHub itself (see this blogpost).  These links also work on the documentation website, as they are automatically replaced by the correct URL.  Take for example a look at the documentation of the mappers or the examples. </p> <p>In addition, it is also possible to link to (sub)sections of a file. It is less straightforward to find the correct address in this case, but PyCharm gives you suggestions if you type a # behind the filename. Some examples: this paragraph, a CoCoNuT tutorial, setting up a Fluent case, radial basis mappers. This feature has some limitations: it is not possible to link to a section name that appears several times in a file (non-unique name), or to a section name that is a link itself.</p>"},{"location":"docs.html#math","title":"Math","text":"<p>LaTeX notation can be used for writing mathematical expressions. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2), block-style equations in double dolar signs, e.g.</p>  e^{i \\pi} + 1 = 0.  <p>LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation. </p>"},{"location":"docs.html#images","title":"Images","text":"<p>External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory <code>images</code> next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. </p> <p>An image can be added with the MD command</p> <pre><code>![alt](images/example.png \"description\")\n</code></pre> <p>with <code>alt</code> displayed when the image cannot be shown/viewed for some reason, and <code>description</code> appearing when hovering over the image with your mouse. For example:</p> <p></p> <p>Only image formats specified in <code>run_mkdocs.py</code> (i.e. png, jpg, jpeg, gif, svg) are copied to the website; missing extensions can be added.  Images from all <code>coconut</code> subdirectories called <code>images</code> are copied to the website, so care must be taken that <code>images</code> is not used in e.g. the output of the test examples.</p>"},{"location":"docs.html#style-layout-guide","title":"Style &amp; layout guide","text":"<p>This section gives some guidelines about style and layout of MarkDown files, to keep the documentation consistent.</p> <ul> <li> <p>Use code style for:</p> <ul> <li>class and method names (and plurals): <code>Model</code>, <code>ModelParts</code>,<code>__init__</code>,<code>finalize</code></li> <li>JSON keys and values: <code>coupled_solver</code>,<code>delta_t</code></li> </ul> </li> <li> <p>Use code style + italics for:</p> <ul> <li>files: <code>run_simulation.py</code>, <code>parameters.json</code></li> <li>folders: <code>data_structure</code></li> <li>paths: <code>coupling_components/solver_wrappers/mapped.py</code></li> </ul> </li> <li> <p>Use normal text for:</p> <ul> <li>referring to abstract terms and concepts in CoCoNuT (i.e. not a specific class): solver wrappers, mappers, coupled solver, data structure</li> </ul> </li> <li> <p>Titles of MD files (e.g. <code># Mappers</code>, the first line of the MarkDown file):</p> <ul> <li>should be brief and not repeat information that can be deducted from the structure of the documentation, e.g. for the Fluent solver wrapper: just use <code># Fluent</code> and not <code># Fluent solver wrapper</code>, as it is beneath <code>Solver wrappers</code> on the website.</li> <li>don't use class names (and hence no camelcase), e.g. not <code># SolverWrapperOpenFOAM</code></li> </ul> </li> <li> <p>If you refer to other MarkDown pages in the documentation, it can be useful to use a relative link.</p> </li> <li> <p>Recommendation for links: it is nice that the link text gives you some information about where the link goes, for example: </p> <ul> <li>good example: coconut documentation</li> <li>bad example: this link</li> </ul> </li> </ul>"},{"location":"docs.html#creating-a-static-website-with-mkdocs","title":"Creating a static website with MkDocs","text":"<p>MkDocs can be installed using pip:  <pre><code>pip install mkdocs-material\n</code></pre> Apart from MkDocs, this also automatically installs the Material theme and the PyMdown MD extensions (including Arithmatex). </p> <p>To install locally, add a relative or absolute path with the <code>-t</code> argument: <pre><code>pip install mkdocs-material -t /some/absolute/path\n</code></pre> In this case, two lines must be added to your <code>.bashrc</code> file:  <pre><code>export PYTHONPATH=/some/absolute/path:$PYTHONPATH\nexport PATH=/some/absolute/path/bin:$PATH\n</code></pre></p> <p>The structure/outline of the website is dictated by the <code>nav</code> variable in <code>mkdocs.yml</code>. This is the only variable that must be adjusted when new MD files are added to the code.</p> <p>The complete process to create the documentation website is automated by <code>run_mkdocs.py</code>. This does the following things:</p> <ul> <li>Copy all MD files in <code>coconut</code> and its subfolders to folder <code>docs</code>. </li> <li>Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths.</li> <li>Check if each MD file is mentioned in <code>mkdocs.yml</code>. If a file is not mentioned, a warning is given.</li> <li>Build static HTML website using <code>mkdocs build</code>. </li> </ul> <p>You can run <code>run_mkdocs.py</code> with an extra command line argument: </p> <p><pre><code>python3 run_mkdocs.py --preview example\n</code></pre> opens a preview of the website in Firefox, showing the webpage corresponding to the file <code>example.md</code>. This can be used to check MD and LaTeX syntax. </p> <p><pre><code>python3 run_mkdocs.py --deploy\n</code></pre> deploys the website on GitHub Pages using <code>mkdocs gh-deploy</code>. It seems this is currently only possible if the remote is configured with SSH, not with HTTPS.  </p>"},{"location":"examples.html","title":"Examples","text":"<p>This documentation describes the structure of the different example cases and how to run them.</p>"},{"location":"examples.html#folder-and-file-structure","title":"Folder and file structure","text":"<p>The <code>examples</code> folder contains different examples grouped per case, for example, the cases calculating the flow through a flexible tube is gathered in the folder <code>tube</code>.</p> <p>Each case folder, such as <code>tube</code>, contains the following directories and files:</p> <ul> <li><code>setup_files</code> containing the necessary files to set up the case for each solver,</li> <li><code>&lt;flow solver&gt;_&lt;structural solver&gt;</code> different folders solving the case with different solver combinations, hereafter simply called examples.</li> </ul> <p>The following files can be found in each example:</p> <ul> <li><code>parameters.json</code> the parameter file in JSON format specifying the settings for the CoCoNuT simulation, and which can be interpreted as a dictionary (there are two main keys, the first is <code>settings</code> in which the number of time steps for which the calculation is run is specified and the second is <code>coupled_solver</code> in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solver wrappers),</li> <li><code>setup_case.py</code> the Python script used to create the working directories (copying them from <code>setup_files</code>, mentioned earlier), to set up the case for the different solvers and to copy <code>run_simulation.py</code> (note that these folders are expandable and are overwritten when the setup file is (re)run), </li> <li><code>tube_&lt;flow solver&gt;_&lt;structural solver&gt;.md</code> description of the specific example,</li> <li>optionally other files which can be used for visualization of the interface data or for comparison with benchmark data.</li> </ul> <p>Besides the case folders, such as <code>tube</code>, the <code>examples</code> folder contains other directories:</p> <ul> <li><code>test_single_solver</code> particular example of the coupled solver <code>test_single_solver</code> that can be used to test the setup of case by only running one solver and replacing the other solver with a dummy solver that outputs prescribed data,</li> <li><code>post_processing</code> containing the code to inspect and visualize your results, see also the post-processing documentation, given that your results are stored in a pickle file, see the documentation on save results.</li> <li><code>run_simulation.py</code> the script used to start the actual simulation,</li> <li><code>images</code> folder containing images used in the description of the examples,</li> <li><code>evaluate_examples</code> Python script to compare the results of the example simulation with benchmark data,</li> <li><code>benchmark_files</code> folder containing the benchmark data in the form of pickle files and a Python script to create this data.</li> </ul>"},{"location":"examples.html#running-a-case","title":"Running a case","text":"<p>In order to run an example, first, navigate to the example and run the setup script to create the working directories and set up the cases for each solver. This script also copies <code>run_simulation.py</code> to the example. The calculation is started by running <code>run_simulation.py</code>.</p> <p>In practice, you will run the following commands: <pre><code>python3 setup_case.py\npython3 run_simulation.py\n</code></pre></p> <p>Important CoCoNuT launches each solver in its own environment, avoiding potential conflicts. This means that CoCoNuT needs to know the commands to make the software available on your machine. These commands are specified in the <code>coconut/solver_modules.py</code> file, in the dictionary <code>solver_load_cmd_dict</code>. It's important to add your own machine to this dictionary and to specify the <code>machine_name</code> correspondingly. The solvers for the UGent-cluster have already been added to the file. If it's not necessary to, for example, load modules, on your machines, an empty string should be used.</p>"},{"location":"examples.html#setting-up-your-own-case","title":"Setting up your own case","text":"<p>To set up your own case, following items should be present:</p> <ul> <li>a JSON file containing the parameters of your simulation; in the examples, this file is called <code>parameters.json</code>, but you can deviate from this convention as long as the variable <code>parameter_file_name</code> in the <code>run_simulation.py</code> script is modified,</li> <li>a <code>run_simulation.py</code> script which starts the CoCoNuT simulation when run,</li> <li>working directories for the used solvers, contain the case files required for the calculations; in the examples they are named <code>CFD</code> and <code>CSM</code>, respectively for the flow and structural solvers, but they can have any name as long as they are referenced correctly in the parameter file under the keyword <code>working_directory</code>.</li> </ul> <p>Finally, some tips are listed to successfully set up you and run your own case:</p> <ul> <li>Although it is not required, it can be a good idea to set up your case using a set-up-script and folder with setup-files as in the examples, allowing you to easily and reproducibly start from a clean case.</li> <li>The easiest way to get started is to start from an existing example closest to your own case and modify the files as required.</li> <li>Before coupling your solvers, it is wise to test them first separately using <code>test single solver</code> and a <code>dummy solver</code>, which can prescribe, for example, displacement of the interface. This way it can be verified if the solvers behave as expected before coupling them together.</li> <li>The scripts for animating the data on the interface provided in <code>post_processing</code> can be a handy tool to understand possible issues.</li> </ul>"},{"location":"fluent.html","title":"Fluent","text":"<p>This is the documentation for all Fluent solver wrappers. The focus of this page is on fluid-structure interaction (FSI). Currently no other multiphysics problems are supported, but these are envisioned in future developments. FSI with inviscid flows is not supported, but that would be straightforward to add if required.</p>"},{"location":"fluent.html#fluid-structure-interaction-with-fluent","title":"Fluid-structure interaction with Fluent","text":"<p>ANSYS Fluent can be used to solve the flow field in partitioned FSI simulations. The FSI interface consists of one or several surface threads in Fluent.  During each FSI iteration, the solver wrapper imposes a certain displacement on this FSI interface. Fluent then automatically deforms the rest of the mesh (using dynamic mesh capabilities), solves the flow field and returns the calculated loads on the FSI interface to the solver wrapper.  Displacements are applied in Fluent in nodes. As displacements are the input of Fluent, these nodes are collected in one or more <code>ModelParts</code> in the input <code>Interface</code>.  Loads (pressure and traction) can be obtained from the Fluent faces. As loads are the output of Fluent, these faces are collected in one or more <code>ModelParts</code> in the output <code>Interface</code>. A fixed naming convention is used for the Fluent <code>ModelParts</code> in CoCoNuT: each <code>ModelPart</code> gets the name of the corresponding Fluent surface thread, plus \"_nodes\" or \"_faces\", depending on their content. As a consequence, each <code>ModelPart</code> in the input <code>Interface</code> has a counterpart in the output <code>Interface</code>.  More information about <code>ModelParts</code> and <code>Interfaces</code> can be found in the data structure documentation.</p>"},{"location":"fluent.html#parameters","title":"Parameters","text":"<p>This section describes the parameters in the JSON file, listed in alphabetical order.</p> parameter type description <code>case_file</code> str Name of the case file. It must be present in the folder specified by <code>working_directory</code>. The corresponding data file must also be present but has no key in the JSON file. <code>cores</code> int Total number of processor cores to use when running Fluent. When its value is negative or bigger than the maximum number of available cores, it will be automatically replaced by the maximum number of available cores. <code>debug</code> bool (optional) Default: <code>false</code>. For every iteration, text files are saved with the input and output data of the solver. <code>delta_t</code> float Fixed time step size in flow solver. This parameter is usually specified in a higher <code>Component</code>. <code>dimensions</code> int Dimension used in flow solver: <code>2</code> for 2D and axisymmetric, <code>3</code> for 3D. <code>end_of_timestep_commands</code> str (optional) Fluent journal command(s) to be executed after every time step, to store drag and lift forces for example. <code>flow_iterations</code> int Number of non-linear iterations in Fluent per coupling iteration. <code>fluent_gui</code> bool Set to <code>true</code> to run Fluent with the graphical interface. <code>interface_input</code> list List of dictionaries to describe the input <code>Interface</code> (Fluent nodes). Each dictionary defines one <code>ModelPart</code> with two keys: <code>model_part</code> contains the name of the <code>ModelPart</code> and <code>variables</code> contains a list of variable names. Each <code>ModelPart</code> name must be the concatenation of an entry from <code>thread_names</code> and \"_nodes\". The variable names must be chosen from <code>data_structure/variables.py</code>. <code>hosts_file</code> str (optional) Filename of the hosts file in case of a multi-node job, this file has to be in the <code>working_directory</code> and contain the names of the available machines. Not required for single-node jobs. <code>interface_output</code> dict Analogous to <code>interface_input</code>, but for the output <code>Interface</code> (Fluent faces). Each <code>ModelPart</code> name must be the concatenation of an entry from the file <code>thread_names</code> and \"_faces\". <code>max_nodes_per_face</code> int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces and 2 in 2D simulations (edges). <code>multiphase</code> bool (optional) Default <code>false</code>. <code>true</code> for multiphase Fluent case, <code>false</code> for singlephase. <code>print_coupling_convergence</code> bool (optional) Default <code>false</code>. If <code>true</code> and if the solver coupling convergence is checked, a statement is printed when the solver converges in the first solver iteration, see solver coupling convergence. <code>save_results</code> int (optional) Default <code>1</code>. Number of time steps between consecutive saves of the Fluent case and data files. <code>thread_names</code> list List with Fluent names of the surface threads on the FSI interface. <code>timestep_start</code> int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the <code>case_file</code>, else the code looks for the relevant case and data files. This parameter is usually specified in a higher <code>Component</code>. <code>unsteady</code> bool <code>true</code> for transient FSI, <code>false</code> for steady FSI. <code>working_directory</code> str Absolute path to the working directory or relative path w.r.t the current directory. <p><code>timestep_start</code> and <code>delta_t</code> are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed.</p> <p>If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.</p>"},{"location":"fluent.html#overview-of-operation","title":"Overview of operation","text":"<p>The solver wrapper consists of 3 files (with X the Fluent version, e.g. \"v2023R1\"):</p> <ul> <li><code>X.py</code>: defines the <code>SolverWrapperFluentX</code> class, </li> <li><code>fluent.jou</code>: Fluent journal file to interactively run the FSI simulation, written in Scheme, </li> <li><code>fluent.c</code>: Fluent UDF file that implements additional functionality used in Fluent, written in C.</li> </ul>"},{"location":"fluent.html#the-initialize-method","title":"The <code>initialize</code> method","text":"<p>During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the <code>working_directory</code>. Fluent is then started in that directory using the parameters <code>cores</code>, <code>dimensions</code> and <code>fluent_gui</code>. Fluent then writes a case summary, so that the solver wrapper can link the interface thread names (specified in <code>thread_names</code>) to Fluent thread IDs, for use in the UDFs. Then the <code>Model</code> and <code>ModelParts</code> are created, based on data written by Fluent in time step 0. After a restart, this same data must be found, i.e. if those data files are removed from the <code>working_directory</code> folder, the simulation cannot be restarted. Finally, the <code>Interfaces</code> are created. </p>"},{"location":"fluent.html#files-created-during-simulation","title":"Files created during simulation","text":"<p>In these file conventions, A is the time step number and B the Fluent thread ID.</p> <ul> <li>Fluent case and data files are saved as files of the form <code>case_timestepA.cas</code> and <code>case_timestepA.dat</code>.</li> <li>Current node and face coordinates are passed from Fluent to CoCoNuT with files of the form <code>nodes_timestepA_threadB.dat</code> and <code>faces_timestepA_threadB.dat</code>. </li> <li>The new node coordinates are passed from CoCoNuT to Fluent with files of the form <code>nodes_update_timestepA_threadB.dat</code>.</li> <li>Pressure and tractions are passed from Fluent to CoCoNuT with files of the form <code>pressure_traction_timestepA_threadB.dat</code>.</li> <li>Files with extension <code>.coco</code> are used to exchange messages between CoCoNuT and Fluent. </li> </ul>"},{"location":"fluent.html#setting-up-a-new-case","title":"Setting up a new case","text":"<p>Following items should be set up and saved in the Fluent case file (this list may be non-exhaustive):</p> <ul> <li>additional UDFs must be configured, </li> <li>steady/unsteady (should match with the <code>unsteady</code> parameter),</li> <li>2D, 3D or axisymmetric (should match with the <code>dimensions</code> parameter),</li> <li>dynamic mesh zones for all deforming surfaces, except for the FSI interfaces,</li> <li>dynamic mesh smoothing parameters,</li> <li>boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria.</li> </ul> <p>A data file should also be present with the fields either initialized or containing the results of a previous calculation.</p> <p>Following items are taken care of by CoCoNuT, and must therefore not be included in the Fluent case file:</p> <ul> <li>dynamic mesh zones for the FSI interfaces (these are defined in <code>thread_names</code>),</li> <li>the time step (<code>delta_t</code>).</li> </ul>"},{"location":"fluent.html#running-multinode","title":"Running multinode","text":"<p>To start a multinode simulation, a hosts file has to be present in the working directory. This is a text file containing the machine names, each on a new line. The name of this file has to be communicated to CoCoNuT by providing it as the value of the parameter <code>\"hosts_file\"</code> in the Fluent JSON settings.</p> <p>For example, on the HPC system of the UGent, such a file with name <code>fluent.hosts</code> can be created with the command <pre><code>cat $PBS_NODEFILE &gt; fluent.hosts\n</code></pre></p>"},{"location":"fluent.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The convergence criterion solver coupling convergence is implemented for the Fluent solver wrapper. Instead of comparing the different residuals (continuity, x-velocity, ...) with their respective tolerances before the first iteration, they are checked after the first iteration due to implementation restrictions.</p>"},{"location":"fluent.html#version-specific-documentation","title":"Version specific documentation","text":"<p>The results can be slightly different when restarts are used for multi-core simulations for the following reason: For parallel cases with smoothing that do not use dynamic load balancing, a zonal partitioning with Laplace smoothing will automatically be applied when the file is read, which should result in better load balancing for the mesh smoothing calculations. After a restart, the partitioning can be different and hence the mesh deformation can be slightly different.</p>"},{"location":"fluent.html#v2023r1-2310","title":"v2023R1 (23.1.0)","text":"<p>No major changes.</p>"},{"location":"fluent.html#v2024r1-2410","title":"v2024R1 (24.1.0)","text":"<p>No major changes.</p>"},{"location":"fluent.html#v2024r2-2420","title":"v2024R2 (24.2.0)","text":"<p>No major changes.</p>"},{"location":"kratos_structure.html","title":"KratosStructure","text":"<p>KratosMultiphysics is an open source framework for finite element simulations. More information on Kratos and the source code can be found on the Kratos GitHub page.  The solver wrapper of <code>StructuralMechanicsApplication</code> from Kratos has been implemented in CoCoNuT. This a documentation of this solver wrapper. </p>"},{"location":"kratos_structure.html#parameters","title":"Parameters","text":"<p>This section describes the parameters in the JSON file, listed in alphabetical order.</p> parameter type description <code>debug</code> bool (optional) Default: <code>false</code>. For every iteration, text files are saved with the input and output data of the solver. <code>delta_t</code> double (optional) Fixed time step size in structural solver. <code>input_file</code> str Project parameters file used by Kratos in JSON format. In the example cases, this is typically called <code>ProjectParameters.json</code>. <code>interface_input</code> dict List of dictionaries that describes the input <code>Interface</code>. This provides the  interface boundary conditions for the Kratos solver. Each entry in the list has two keys: <code>model_part</code> and <code>variables</code>, with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the  <code>variables_dimensions</code> <code>dict</code> in  the file <code>coconut/data_structure/variables.py</code>. The model part name must be the concatenation of an entry from <code>kratos_interface_sub_model_parts_list</code> and the string <code>_input</code>. <code>interface_output</code> dict Analogous to <code>interface_input</code>, but here the name must be the concatenation of an entry from <code>kratos_interface_sub_model_parts_list</code> and the string <code>_output</code>. The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. <code>kratos_interface_sub_model_parts_list</code> str Names of sub-model parts used for input and output in Kratos. <code>pressure_directions</code> list A list containing 1 or -1 designating the direction in which the pressure is applied: a positive value means NEGATIVE_FACE_PRESSURE is used. This implies applying a pressure on the - face, which hence goes in the direction of the normal (-1,1), in other words 1 should be used when the normal points outwards from the fluid domain. A negative unit value results in the opposite directions, in other words -1 should be used when the normal points into the fluid domain. The length of the list must be equal to that of <code>kratos_interface_sub_model_parts_list</code>. <code>print_coupling_convergence</code> bool (optional) Default <code>false</code>. If <code>true</code> and if the solver coupling convergence is checked, a statement is printed when the solver converges in the first solver iteration, see solver coupling convergence. <code>residual_variables</code> list (optional) A list containing variables as reported in the log file (e.g. DISPLACEMENT, RESIDUAL or RESIDUAL DISPLACEMENT) whose residuals you need to output. If provided, this will output the last residual for each FSI-coupling iteration in <code>&lt;case_directory&gt;/residuals.csv</code>. For different element types, the names might be different and/or changes might be required to parse the log file. For the correct names see the Kratos log file. <code>structure_iterations</code> int (optional) Maximum number of Newton iterations in Kratos per coupling iteration. If not provided, the value in <code>input_file</code> is used. <code>timestep_start</code> int (optional) Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. <code>working_directory</code> str Path to the working directory (i.e. where the <code>input_file</code> for Kratos is located), either absolute or relative w.r.t the current directory (i.e. from where the analysis is started). <p><code>timestep_start</code> and <code>delta_t</code> are usually defined in the parameters of the <code>coupled_solver</code>. However, they can also be given directly as a parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed.</p> <p>If different parameters are used with different Kratos versions, this should be specified both in this section and in the version specific documentation section.</p>"},{"location":"kratos_structure.html#overview-of-operation","title":"Overview of operation","text":"<p>The solver wrapper consists of 2 files, where <code>X</code> is the Kratos version without decimal, e.g. for version 6.0 this becomes <code>60</code>:</p> <ul> <li><code>vX.py</code>: defines the <code>SolverWrapperKratosStructureX</code> class,</li> <li><code>run_kratos_structural_X.py</code>: The Python file which runs Kratos in the background. This interacts with CoCoNuT for coupling.</li> </ul>"},{"location":"kratos_structure.html#the-__init__-method","title":"The <code>__init__</code> method","text":"<p>During initialization, the <code>ProjectParameters.json</code> file required for Kratos simulation is read and modified (parameter values are filled in) in the <code>working_directory</code>.  One additional parameter called  <code>interface_sub_model_parts_list</code> is added in the <code>ProjectParameters.json</code> that tells Kratos about the interface model parts used in the coupling.  Kratos structural simulation is then started in that directory using the parameter <code>cores</code> (multiprocessing not implemented yet).  The solver wrapper waits for the Kratos simulation to output interface sub-model parts nodes, so that <code>SolverWrapperKratosStructureX</code> can create model parts in CoCoNuT for each entry in <code>interface_input</code> and <code>interface_output</code>.  Finally, the interfaces are created.</p>"},{"location":"kratos_structure.html#files-created-during-simulation","title":"Files created during simulation","text":"<ul> <li>The interface sub-model parts nodes are saved as <code>&lt;sub_model_part_name&gt;_nodes.csv</code>.</li> <li>The displacement from Kratos is written in a file named <code>&lt;sub_model_part_name&gt;_displacement.csv</code>.</li> <li>Pressure and tractions are passed from Python to Kratos with files of the form <code>&lt;sub_model_part_name&gt;_pressure.csv</code> and <code>&lt;sub_model_part_name&gt;_surface_load.csv</code>, respectively.</li> <li>Files with extension <code>.coco</code> are used to pass messages between Python and Kratos.</li> </ul>"},{"location":"kratos_structure.html#setting-up-a-new-case","title":"Setting up a new case","text":"<p>Following items should be set up and saved in the <code>working_directory</code> (this list may be non-exhaustive):</p> <ul> <li><code>ProjectParameters.json</code> with all the required parameters (see the example cases)</li> <li>Mesh file with extension <code>.mdpa</code></li> <li><code>StructuralMaterials.json</code> with the material properties</li> </ul> <p>Following items are taken care of by CoCoNuT, and must therefore will be automatically changed at the begining of the simulation:</p> <ul> <li>The start time (<code>timestep_start</code>)</li> <li>The time step (<code>delta_t</code>)</li> <li>Initialization of the solution field</li> </ul>"},{"location":"kratos_structure.html#tip","title":"Tip","text":"<p><pre><code>When starting a simulation from time=0 after having restarted in the same folder, clean the directory or delete the case folder and copy the required files from a \"set up\" folder.\n</code></pre> The reason for this is that the <code>ProjectParameters.json</code> file is modified when performing restart in such a way that it can no longer be used to start from time=0.</p>"},{"location":"kratos_structure.html#post-processing","title":"Post-processing","text":"<p>Kratos <code>StructuralMechanicsApplication</code> v91 allows for saving VTK files. The number of files saved is set in <code>ProjectParameters.json</code> and is not modified by CoCoNuT. Note that the zeroth instance corresponds to the first time step.</p>"},{"location":"kratos_structure.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The convergence criterion solver coupling convergence is implemented for the Kratos StructuralMechanics solver wrapper.</p> <p>When using the <code>residual_criterion</code> in Kratos as convergence criterion, it's important to set the relative tolerance to <code>-1</code>, effectively disabling it. This is needed because Kratos sets the relative residual to zero in the first time step, wrongly leading to immediate convergence. Although this is also the case when other coupling convergence criteria are used, it deserves special attention in case of the solver coupling convergence criterion.</p> <p>Below, an example of the <code>ProjectParameters.json</code> file is included using the <code>and_criterion</code>. This criterion combines the displacement and residual criteria and declares the solver converged only if both criteria are satisfied. <pre><code>{\n  ...\n  \"convergence_criterion\": \"and_criterion\",\n  \"displacement_relative_tolerance\": 1e-7,\n  \"displacement_absolute_tolerance\": 1e-7,\n  \"residual_relative_tolerance\": -1,\n  \"residual_absolute_tolerance\": 1e-7,\n  ...\n}\n</code></pre></p>"},{"location":"kratos_structure.html#version-specific-documentation","title":"Version specific documentation","text":""},{"location":"kratos_structure.html#v94-94","title":"v94 (9.4)","text":"<p>Base version.</p>"},{"location":"kratos_structure.html#kratos-installation","title":"Kratos installation","text":"<p>This version supports installation using <code>pip</code>. To install only StructuralMechanicsApplication of Kratos, use the following command: <pre><code>pip install KratosMultiphysics KratosStructuralMechanicsApplication KratosLinearSolversApplication\n</code></pre> Note, the linear solvers in <code>KratosLinearSolversApplication</code> is sometimes used by the <code>StructuralMechanicsApplication</code>, therefore it is installed along with it.</p> <p>To install all the available applications in Kratos, use the following command: <pre><code>pip install KratosMultiphysics-all\n</code></pre></p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html","title":"Lid-driven cavity case with Fluent2D and KratosStructure2D","text":"<p>This case is an FSI-adaptation of the famous lid-driven cavity case, calculated using Fluent and KratosMultiphysics StructuralMechanicsApplication. Here, the bottom wall is deformable and an oscillatory velocity is applied at the top.</p> <p></p> <p>The oscillatory x-component of the velocity is applied not only at the top, but also in a region at the upper left side wall. As shown in the figure above, the velocity increases linearly with the height. The y-component of the velocity is zero. The oscillating velocity \\bar{v} is given by $$ \\bar{v}=1-\\cos\\left(\\frac{2\\pi t}{5}\\right), $$ with t the time. On the corresponding region on the right side, zero pressure is applied. The deformable bottom is fixed at the corners.</p> <p>The fluid parameters are:</p> <ul> <li>density: 1 kg/m\u00b3</li> <li>dynamic viscosity: 0.01 Pa\\cdots</li> </ul> <p>The deformable bottom is fixed at its left and right side and consists of a linear elastic material with the follwing properties:</p> <ul> <li>density: 500 kg/m\u00b3</li> <li>modulus of elasticity: 250 Pa</li> <li>poisson's ratio: 0.0</li> </ul> <p>The total simulated time is 70 s in time steps of 0.1 s.</p> <p>Reference solutions are available from Mok [1] and Valdes [2]. The figure belows shows a comparison with the solution of the examples with Fluent and OpenFOAM.</p> <p></p> <p>The following figures show contour plots of the pressure and velocity for this example (with Fluent).</p> <p> </p> <p>A script <code>evaluate_benchmark.py</code> is provided to compare the results with the benchmark results in [1] and lid_driven_cavity_. Furthermore, the script <code>animate_lid_driven_cavity.py</code> can be used to visualize the interface data throughout the calculation.</p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). No reuse is employed, so the reuse parameter <code>q</code> is set to 0.</p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm of the displacement is smaller than 10^{-9}.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html#solvers","title":"Solvers","text":"<p>Fluent is used as flow solver. A quadrilateral mesh is used with 32 cells on each side of the cavity. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. Dynamic mesh motion is achieved using a spring method.</p> <p>The structural solver is KratosMultiphysics StructuralMechanicsApplication (abbreviated KratosStructure). The deformable bottom is meshed with 2 layers of 32 TotalLagrangianElement2D4N elements. The movement of the left and right side is constrained.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x-direction from and to the coupled solver.</p>"},{"location":"lid_driven_cavity_fluent2d_kratos_structure2d.html#references","title":"References","text":"<p>[1] Mok D. P., \u201cPartitionierte L\u00f6sungsans\u00e4tze in der Strukturdynamik und der Fluid\u2212Struktur\u2212Interaktion\u201d, PhD thesis: Institut f\u00fcr Baustatik, Universit\u00e4t Stuttgart, 2001.</p> <p>[2] Vald\u00e9s G. and Gerardo J., \u201cNonlinear Analysis of Orthotropic Membrane and Shell Structures Including Fluid-Structure Interaction\u201d, PhD thesis: Universitat Polit\u00e8cnica de Catalunya, 2007.</p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html","title":"Lid-driven cavity case with OpenFOAM2D and KratosStructure2D","text":"<p>This case is an FSI-adaptation of the famous lid-driven cavity case, calculated using OpenFOAM and KratosMultiphysics StructuralMechanicsApplication. For more information with respect to this case refer to this example.</p> <p>Reference solutions are available from Mok [1] and Valdes [2]. The figure belows shows a comparison with the solution of the examples with Fluent and OpenFOAM.</p> <p></p> <p>The following figures show contour plots of the pressure and velocity for this example (with Paraview).</p> <p> </p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). No reuse is employed, so the reuse parameter <code>q</code> is set to 0.</p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 10.</li> <li>The residual norm of the displacement is smaller than 10^{-9}.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html#solvers","title":"Solvers","text":"<p>The flow solver is the OpenFOAM solver pimpleFOAM. A quadrilateral mesh is used with 32 cells on each side of the cavity, made with blockMesh.</p> <p>The structural solver is KratosMultiphysics StructuralMechanicsApplication (abbreviated KratosStructure). The deformable bottom is meshed with 2 layers of 32 TotalLagrangianElement2D4N elements. The movement of the left and right side is constrained.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. Because a two-dimensional calculation in OpenFOAM has one cell in the depth direction, the coordinates of the nodes are actually three-dimensional. Therefore, the displacement serving as input to the flow solver is first mapped using the mapper MapperDepth2DTo3D and subsequently mapped using a radial basis mapper. The resulting pressure and traction forces are located on the face centers, which all lie in the same plane as where the forces are applied in the structural solver. This means no additional transformer is required and only a radial basis mapper has to be applied. Mapping the flow solver instead of the structural solver, means that the coupled solver will work with the interface containing the displacements stored in Kratos nodes and not the interface which has stored the displacements in twice as many OpenFOAM nodes.</p>"},{"location":"lid_driven_cavity_openfoam2d_kratos_structure2d.html#references","title":"References","text":"<p>[1] Mok D. P., \u201cPartitionierte L\u00f6sungsans\u00e4tze in der Strukturdynamik und der Fluid\u2212Struktur\u2212Interaktion\u201d, PhD thesis: Institut f\u00fcr Baustatik, Universit\u00e4t Stuttgart, 2001.</p> <p>[2] Vald\u00e9s G. and Gerardo J., \u201cNonlinear Analysis of Orthotropic Membrane and Shell Structures Including Fluid-Structure Interaction\u201d, PhD thesis: Universitat Polit\u00e8cnica de Catalunya, 2007.</p>"},{"location":"mappers.html","title":"Mappers","text":"<p>The coupling interfaces in different solvers are often discretized (meshed) differently, resulting in non-conforming <code>ModelParts</code>. For this reason, mapping is usually required, to transfer data from the output <code>Interface</code> of one solver to the input <code>Interface</code> of another. </p> <p>The terms from and to will be used to denote respectively the side that provides the original data and the side that receives the mapped data.  </p>"},{"location":"mappers.html#general-concepts","title":"General concepts","text":""},{"location":"mappers.html#hierarchy-of-mapping-related-objects","title":"Hierarchy of mapping-related objects","text":"<p>CoCoNuT interacts with the mappers through an instance of the <code>SolverWrapperMapped</code> class. This special solver wrapper appears and behaves exactly the same as real solver wrappers. It contains 3 <code>Components</code>: a mapper for the input, a real solver wrapper and a mapper for the output.</p> <p>The two mappers in the <code>SolverWrapperMapped</code> are of a special type: they work on the level of the <code>Interfaces</code>, while the actual mapping will be done on a lower level: the <code>ModelPart</code> level. The <code>Interface</code> mapper effectively acts as a wrapper around the actual <code>ModelPart</code> mappers. Currently only one mapper is available on the <code>Interface</code> level, aptly called <code>MapperInterface</code>.</p> <p>At the lowest level, mappers interpolate variable data (stored in <code>Interfaces</code>) between two <code>ModelParts</code>, based on their coordinates. Interpolation is always done from the from <code>ModelPart</code> to the to-<code>ModelPart</code>. Multiple <code>ModelPart</code> mappers can be chained together in a <code>MapperCombined</code> object, to add additional functionality, for example swapping the coordinate axes with the permutation mapper.</p>"},{"location":"mappers.html#interpolators-and-transformers","title":"Interpolators and transformers","text":"<p>The <code>ModelPart</code>-level mappers have two main methods: <code>initialize</code> and <code>__call__</code>.  The <code>initialize</code> method performs one-time expensive operations, such as a nearest-neighbour search and the calculation of interpolation coefficients.  The <code>__call__</code> method is used for the actual mapping. It takes two tuples as arguments (from and to respectively). Each tuple contains an <code>Interface</code> object, the name of the affected <code>ModelPart</code> and the name of the variable that must be mapped. This method returns nothing: the mapping is done in-place in the to-<code>Interface</code>.</p> <p>There are two types of <code>ModelPart</code> mappers: interpolators and transformers. They can be distinguished by their superclass.  All interpolators inherit from the superclass <code>MappedInterpolator</code>. These mappers do the actual interpolation. Currently, a nearest-neighbour mapper, a linear mapper and a radial basis mapper are available. All transformers inherit from the superclass <code>MappedTransformer</code>. They provide additional functionality that can be useful during mapping. They do not map values from one point cloud to another like the interpolators, but perform one-sided transformations on the coordinates and/or the data. One example is the permutation transformer: it swaps the coordinate axes of the <code>ModelPart</code> and accordingly the components of vector variables.  A transformer can never be used by itself, it must always be combined with an interpolator. The reason is that interpolators use information that comes from two sides, which is exactly what the higher-level <code>SolverWrapperMapped</code> and <code>MapperInterface</code> objects are supplying. To chain together multiple <code>ModelPart</code> mappers, the <code>MapperCombined</code> is used: it contains always one interpolator and zero or more transformers, on either side of the interpolator.</p>"},{"location":"mappers.html#special-mapper-classes","title":"Special mapper classes","text":""},{"location":"mappers.html#mapperinterface","title":"<code>MapperInterface</code>","text":"<p>Class that maps on the level of <code>Interface</code> objects.  It takes two <code>Interfaces</code>, and maps the <code>ModelParts</code> to each other in the order in which the <code>Interfaces</code> are defined in the JSON file. The same type of <code>ModelPart</code> mapper is used for each pair of <code>ModelParts</code>: this can either be an interpolator or a combined mapper. To use a different <code>ModelPart</code> mapper for the different <code>ModelParts</code> in the <code>Interface</code>, or even for different variables, a new <code>Interface</code> mapper would have to be written. </p> parameter type description <code>type</code> str <code>ModelPart</code> mapper to be used. <code>settings</code> dict All the settings for the <code>ModelPart</code> mapper specified in <code>type</code>."},{"location":"mappers.html#mapperinterpolator","title":"<code>MapperInterpolator</code>","text":"<p>Superclass for all interpolators. </p> parameter type description <code>balanced_tree</code> bool (optional) Default: <code>false</code>. If set to <code>true</code> a balanced <code>cKDTree</code> is created, which is more stable, but takes longer to build. Set to <code>true</code> in the rare case that the tree gives problems. <code>check_bounding_box</code> bool (optional) Default: <code>true</code>. If <code>true</code> it is checked if the bounding boxes of the from- and to-<code>ModelParts</code> overlap in the provided mapping <code>directions</code>. <code>directions</code> list List of coordinate directions, maximum three entries, may contain <code>\"x\"</code>, <code>\"y\"</code>, <code>\"z\"</code>. <code>scaling</code> list (optional) Default: no scaling. List of scaling factors, must be same length as <code>directions</code>. Coordinates are scaled with these factors, this may improve interpolation e.g. when cells have a high aspect ratio with respect to one of the axes. <p>The <code>initialize</code> method must be defined in all child classes. It takes as arguments the from-<code>ModelPart</code> and the to-<code>ModelPart</code>. It does the following:</p> <ul> <li>read and store the coordinates from the from- and to-<code>ModelParts</code>,</li> <li>scale coordinates if necessary,</li> <li>check if the bounding boxes of the from- and to-<code>ModelParts</code> overlap,</li> <li>do an efficient nearest neighbour search using <code>scipy.spatial.cKDTree</code>,</li> <li>check if the from-<code>ModelPart</code> does not contain duplicate coordinates.</li> </ul> <p>The <code>__call__</code> method should not be overridden in the child classes. It interpolates data based on coefficients that are calculated in the <code>initialize</code> method of the child classes. Both scalar and vector variables can be mapped.</p>"},{"location":"mappers.html#mappertransformer","title":"<code>MapperTransformer</code>","text":"<p>Superclass for all transformers. A transformer cannot be used as a standalone mapper, but will always be part of a combined mapper. </p> <p>The <code>initialization</code> of transformers is very different from that of interpolators. A transformer is initialized from one side (either the from or the to side), i.e. based on a single <code>ModelPart</code>. From this input <code>ModelPart</code>, the <code>initialize</code> method creates and returns another <code>ModelPart</code> that is stored and used in the combined mapper. </p>"},{"location":"mappers.html#mappercombined","title":"<code>MapperCombined</code>","text":"parameter type description <code>mappers</code> list An ordered list of all the <code>ModelPart</code> mappers to be used. <p>The <code>MapperCombined</code> is used to chain together multiple mappers. It always contains a single interpolator and zero or more transformers, which can be on either side of the interpolator. If transformers are present, intermediate <code>ModelParts</code> are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from-<code>ModelPart</code> (input), while downstream transformers are initialized based on the to-<code>ModelPart</code> (output).  Some transformers can only be initialized in one direction, e.g. for <code>MapperAxisymmetric3DTo2D</code>, the 2D to-<code>ModelPart</code> must be supplied, therefore this transformer must be downstream of the interpolator. </p> <p>These concepts are clarified further using an excerpt from the JSON file of the Fluent 3D - Abaqus 2D tube example: </p> <p><pre><code>{\n\"type\": \"mappers.combined\",\n\"settings\": {\n    \"mappers\": [\n        {\"type\": \"mappers.permutation\",\n        \"settings\": {\"permutation\": [1, 0, 2]}},\n        {\"type\": \"mappers.radial_basis\",\n        \"settings\": {\"directions\": [\"x\", \"y\", \"z\"]}},\n        {\"type\": \"mappers.axisymmetric_3d_to_2d\",\n        \"settings\": {\"direction_axial\": \"y\", \"direction_radial\": \"x\", \"n_tangential\": 8}}\n        ]\n    }\n}\n</code></pre> This combined mapper contains 3 <code>ModelPart</code> mappers. In the <code>initialize</code> method, the following happens (in this order):</p> <ul> <li>A first intermediate <code>ModelPart</code> is created by calling the <code>initialize</code> method of the permutation transformer. This is done by swapping the x and y coordinates of the from-<code>ModelPart</code>. </li> <li>A second intermediate <code>ModelPart</code> is created by calling the <code>initialize</code> method of the axisymmetric transformer. The coordinates of the 2D to-<code>ModelPart</code> are used to create the 3D intermediate <code>ModelPart</code> by adding points in the circumferential direction.</li> <li>The mapping coefficients of the radial basis interpolator are calculated by calling its <code>initialize</code> method. The first intermediate <code>ModelPart</code> is used as from-<code>ModelPart</code>, the second intermediate <code>ModelPart</code> is used as to-<code>ModelPart</code>.</li> </ul> <p>When the <code>__call__</code> method  of the combined mapper is used, the following happens (in this order):</p> <ul> <li>The from-data (stored in the from-<code>Interface</code>) is mapped from the from-<code>ModelPart</code> to the first intermediate <code>ModelPart</code> using the <code>__call__</code> method of the permutation mapper: scalar variables are unchanged, vector variables are permuted. </li> <li>The resulting data is now interpolated to the second intermediate <code>ModelPart</code>, using the <code>__call__</code> method of the radial basis mapper. </li> <li>Finally, that data is mapped to the to-<code>ModelPart</code> using the <code>__call__</code> method of the axisymmetric transformer, reducing it from 3D to 2D. That data is written to the to-<code>Interface</code>. </li> </ul>"},{"location":"mappers.html#transformers","title":"Transformers","text":""},{"location":"mappers.html#mapperpermutation","title":"<code>MapperPermutation</code>","text":"<p>Permutates the coordinates and the vector variables according to the given <code>permutation</code>.  This transformer can be initialized in both directions. </p> parameter type description <code>permutation</code> list A permutation of the list [0, 1, 2]."},{"location":"mappers.html#mapperaxisymmetric2dto3d","title":"<code>MapperAxisymmetric2DTo3D</code>","text":"<p>Transforms a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric <code>ModelPart</code>. Therefore, it should be upstream of the interpolator in the combined mapper.</p> <p>The 3D <code>ModelPart</code> is returned by the initialization.<code>angle</code> defines the 3D geometry and is based on the geometry of the 3D solver, e.g. the geometry of an axisymmtric simulation with an OpenFoam solver is defined with an angle of 5\u00b0.  <code>n_tangential</code> specifies the number of points in the tangential (circumferential) direction, so that for each point in the 2D <code>ModelPart</code>, <code>n_tangential</code> points are created in the 3D <code>ModelPart</code>. It is important to make the value of <code>n_tangential</code> large enough, ideally close to the number of points in the tangential direction in the 3D solver. The code knows which directions are axial, radial and tangential thanks to the input parameters <code>direction_axial</code> and <code>direction_radial</code>. </p> <p>It is not possible to change the axial direction between 2D and 3D: a separate <code>MapperPermutation</code> should be added to the combined mapper for that purpose. </p> <p>Scalar data is simply copied from the 2D point to all corresponding 3D points. For vector data, the axial component is simply copied, the radial component is rotated. The tangential component (e.g. swirl) is not taken into account currently.</p> <p>Points that lie on the symmetry axis can not be handled by the current transformer.</p> parameter type description <code>direction_axial</code> str Must be <code>\"x\"</code>, <code>\"y\"</code> or <code>\"z\"</code>, specifies the symmetry axis. <code>direction_radial</code> str Must be <code>\"x\"</code>, <code>\"y\"</code> or <code>\"z\"</code>, specifies the second (radial) axis in 2D. <code>n_tangential</code> int Degrees of freedom in tangential (circumferential) direction of 3D <code>ModelPart</code> that is created during initialization. The minimum setting of n_tangential points depends of the definition of the angle. <code>angle</code> int (optional) Default: <code>360</code>. Angle of the (partial) 3D cylinder constructed from the 2D geometry, centred around the radial direction."},{"location":"mappers.html#mapperaxisymmetric3dto2d","title":"<code>MapperAxisymmetric3DTo2D</code>","text":"<p>Transforms a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric <code>ModelPart</code>. Therefore, it should be downstream of the interpolator in the combined mapper.</p> <p>For scalar data, the circumferential average is taken for each 2D point. For vector data too, taking into account the correct radial direction in each 3D point.  Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not transferred to 2D. </p> <p>More information and JSON settings can be found under <code>MapperAxisymmetric2DTo3D</code>.</p>"},{"location":"mappers.html#mapperdepth2dto3d","title":"<code>MapperDepth2DTo3D</code>","text":"<p>Transforms a 2D geometry to a 3D geometry, by extruding in a depth direction. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric <code>ModelPart</code>. Therefore, it should be upstream of the interpolator in the combined mapper.</p> <p>The 3D <code>ModelPart</code> is returned by the initialization. The depth direction in which the 2D <code>ModelPart</code> is extended, is specified by <code>direction_depth</code>. This direction has to be along one of the principal axes: x, y and z. The number of nodes in the depth direction and their location are given by the list <code>coordinates_depth</code>.</p> <p>Scalar data is simply copied from the 2D point to all corresponding 3D points. For vector data, all components other than the depth component are simply copied. The depth component is set to zero.</p> parameter type description <code>coordinates_depth</code> list Contains the depth coordinates to which the nodes of the orignal 2D plane are copied. <code>direction_depth</code> str Must be <code>\"x\"</code>, <code>\"y\"</code> or <code>\"z\"</code>, specifies the symmetry axis."},{"location":"mappers.html#mapperdepth3dto2d","title":"<code>MapperDepth3DTo2D</code>","text":"<p>Transforms a 3D geometry to a 2D axisymmetric geometry, by collapsing in a depth direction. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric <code>ModelPart</code>. Therefore, it should be downstream of the interpolator in the combined mapper.</p> <p>For scalar data, the average is taken for each 2D point. For vector data too, again removing the depth component.</p> <p>More information and JSON settings can be found under <code>MapperDepth2DTo3D</code>.</p>"},{"location":"mappers.html#interpolators","title":"Interpolators","text":""},{"location":"mappers.html#mappernearest","title":"<code>MapperNearest</code>","text":"<p>Does not require additional settings compared to the <code>MapperInterpolator</code>. Does simple nearest-neighbour mapping.</p>"},{"location":"mappers.html#mapperlinear","title":"<code>MapperLinear</code>","text":"<p>Additional settings:</p> parameter type description <code>parallel</code> bool (optional) Default: <code>false</code>. If <code>true</code> the package <code>multiprocessing</code> is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for <code>ModelParts</code> with a very high number of degrees of freedom. <p>The kind of linear mapping depends on the number of coordinate directions, as given in the <code>directions</code> setting.</p> <p>1D: If the to-point lies between the 2 nearest from-points, linear interpolation is done. Else, nearest neighbour interpolation is done.</p> <p>2D: The to-point is first projected on the line through the 2 nearest from-points. If the projected point lies between the from-points, linear interpolation is done. Else, nearest neighbour interpolation is done.</p> <p>3D: The to-point is first projected on the plane through the 3 nearest from-points. If the triangle consisting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.</p>"},{"location":"mappers.html#mapperradialbasis","title":"<code>MapperRadialBasis</code>","text":"<p>Additional settings:</p> parameter type description <code>n_nearest</code> int (optional) Default: <code>81</code>, if mapping in 3 <code>directions</code>, else <code>9</code>. Number of nearest neighbours used to perform mapping. <code>parallel</code> bool (optional) Default: <code>false</code>. If <code>true</code> the package <code>multiprocessing</code> is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for <code>ModelParts</code> with a very high number of degrees of freedom. <code>shape_parameter</code> int (optional) Default: <code>200</code>. Should be chosen as large as possible without rendering the interpolation matrix ill-conditioned. <p>Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using <code>scipy.spatial.distance</code>. </p> <p>Normal radial basis interpolation is done as follows. \\phi(r) is a radial basis function defined as  </p>  \\phi(r) =  \\begin{cases}     (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &amp;\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} &lt; 1 \\\\     0 &amp;\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases}  <p>with r a positive distance. To control the width of the function, r is scaled with a reference distance d_{ref}.</p> <p>Assume that n nearest from-points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) can then be approximated as the weighted sum of n shifted radial basis functions:</p>  f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||)  <p>To determine the coefficients \\alpha_j, we require that the exact function value is returned at the n from-points. This gives us n equations</p>  f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||)  <p>which can be written in matrix form as</p>  \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha}  <p>with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1}, and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n}. This system can be solved for the weights-vector \\boldsymbol{\\alpha}.</p> <p>However, in our case, the from-point values vector \\boldsymbol{f} is not known in advance: it contains the values of the <code>Variable</code> that will be interpolated. </p> <p>Therefore, the approximation to calculate the interpolatoin in the to-point is rewritten as follows:</p>  f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f}  <p>The coefficients vector \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system</p>  \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}.  <p>As every to-point has different nearest neighbours in the from-points, the coefficient vector \\boldsymbol{c} must be calculated for each to-point independently. The matrix \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} must also be calculated for every to-point independently.</p> <p>For every to-point, the reference distance d_{ref} is determined as the product of the <code>shape_parameter</code> and the distance between the to-point and the furthest from-point.</p> <p>In order to ensure that the basis function of each of the nearest from-points covers every from-point, the <code>shape_parameter</code> should be larger than two. This value may however lead to an interpolation function which consists of sharp peaks or wiggles, with the correct value near the from-points, but a deviating value away from them.</p> <p>In the extreme case of d_{ref} approaching zero, the so-called \"bed-of-nails interpolant\" is obtained, which is close to zero everywhere, except near the from-points where it sharply peaks. In this case the interpolation matrix approaches the identity matrix.</p> <p>Choosing a higher value improves the interpolation as the basis functions become wider, but the interpolation matrix becomes less stable, i.e. the condition number increases. The default value is 200. In practice, the <code>shape_parameter</code> is chosen so that the interpolation matrix is \"on the edge of ill-conditioning\" (for example, with a condition number of roughly 10^{13} for double-precision floating point). A warning is printed when the condition number of an interpolation matrix becomes higher than 10^{13}.</p>"},{"location":"models.html","title":"Models","text":"<p>This documentation describes the different types of available models. The purpose of a model always is to provide a (approximated) (inverse) Jacobian of a system. Often this achieved with the help of secant information from input-output-pairs, resulting in a so-called quasi-Newton method. Another approach to obtain an approximated Jacobian is the use of a surrogate model. Finally, in some cases, the Jacobian can be derived analytically. These three types of models will be discussed further. More detailed information can be found in Delaiss\u00e9 et al. [8].</p> <p>Which Jacobian is approximated in practice will depend on the use of the model in the coupled solver. For example, using the coupled solver <code>CoupledSolverIQNI</code> with the model <code>ModelLS</code> corresponds to the IQN-ILS method developed by Degroote et al. [1]. In that case, the approximated Jacobian is \\mathcal{R}'^{-1}. If the coupled solver <code>CoupledSolverIBQN</code> is combined with two instances the model <code>ModelLS</code>, the resulting algorithm corresponds to the IBQN-LS method developed by Vierendeels et al. [2]. Then, the two models each approximate one Jacobian: \\mathcal{F}' and \\mathcal{S}'. Refer to the coupled solvers documentation for more information on these notations.</p>"},{"location":"models.html#common-methods","title":"Common methods","text":"<p>There are four model-specific methods, which are implemented by all models.</p> <ul> <li>The first of which is the <code>predict(dr)</code> method, which returns an estimation of the change in output variable based on a change in input variable using the Jacobian approximation.</li> <li>Second, the method <code>is_ready()</code> return a boolean signalling if the model is ready to predict using the previous method.</li> <li>Third, in order to improve the estimation, information from a current iteration can be added to the model using the method <code>add(r, xt)</code>.</li> <li>And finally, the method <code>filter_q(dr)</code> returns the part of supplied vector which falls inside the nullspace of the Jacobian. This is the part of the supplied vector for which the model has no derivative information.</li> </ul>"},{"location":"models.html#jacobian-approximation-from-secant-information","title":"Jacobian approximation from secant information","text":"<p>In order to approximate the Jacobian \\mathcal{A}' of a general function a=\\mathcal{A}(b), the model needs to be supplied with matching input-output-pairs, (b^i, a^i=\\mathcal{A}(b^i)). Once at least two pairs have been supplied, the model is able to approximately predict the product of the Jacobian with an arbitrary vector \\Delta b. In other words, when a vector \\Delta b is given it outputs \\Delta a=\\widehat{\\mathcal{A}}'\\Delta b, where the hat symbol is used to denote that an approximation of the Jacobain is used.</p> <p>In the following, the example from IQN-ILS will be used: the inverse Jacobian of \\mathcal{R}' with respect to \\widetilde{x} is approximated which has an input vector r and an output vector \\widetilde{x}. For brevity, the approximation will be denoted by N^k, where the superscript k referes to the iteration.</p> <p>The four model-specific methods can be made concrete for this type of model:</p> <ul> <li>The <code>predict(dr)</code> method returns an estimation of \\Delta \\widetilde{x}=N^k\\Delta r from an input \\Delta r, based on stored input-output-pairs.</li> <li>The method <code>is_ready()</code> return a boolean signalling if the <code>model</code> is ready to predict using the previous method. This is the case when two input-output-pairs have been added.</li> <li>The method <code>add(r, xt)</code> adds an input-output-pair to the model in order to improve the estimation.</li> <li>The method <code>filter_q(dr)</code> returns the part of vector \\Delta r which is orthogonal to the columnspace of the matrix containing the differences between consecutively stored inputs. This is the part of the input vector \\Delta r for which the deficient approximation of the Jacobian holds no information.</li> </ul> <p>Three different methods in this category are discussed.</p>"},{"location":"models.html#least-squares","title":"Least-squares","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.ls</code>. The abbreviation LS stands for least-squares.</p> <p>From the received input vectors r^i and output vectors \\widetilde{x}^i, differences are constructed $$ \\delta r^{i-1}=r^i-r^{i-1}, \\; \\delta \\widetilde{x}^{i-1}=\\widetilde{x}^i-\\widetilde{x}^{i-1}. $$ These are stored as column of the matrices V and W. This model requires the approximation of the Jacobian, denoted by N^k, to fulfill the secant equations: $$ W=N^k V. $$ In addition to this a minimal norm requirement is imposed (hence the name).</p> <p>The differences can be limited to the current time step only. However, using the reuse parameter <code>q</code>, the differences from the <code>q</code> previous time steps are included as well. It is important to note that differences between the input and outputs from different time steps are not considered. Reuse may greatly improve the convergence speed and stability. The optimal value of <code>q</code> is problem dependent. Typically, however, an optimal value is around 10.</p> <p>This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The R matrix from the QR-decomposition has to be invertible. Therefore, (almost) linearly dependent columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger <code>q</code>, the more important filtering becomes. If the diagonal element in R is smaller than an absolute tolerance level <code>min_significant</code>, the corresponding column is removed. The implementation is as such that the most recent information is kept.</p> <p>For more information refer to [3].</p> <p>As mentioned before, the combination of this model wiht the coupled solver <code>CoupledSolverIQNI</code> corresponds to the IQN-ILS method developed by Degroote et al. [1], while using twice this model with the coupled solver <code>CoupledSolverIBQN</code> corresponds to the IBQN-LS method developed by Vierendeels et al. [2].</p> <p>The following parameters need to be included in the <code>settings</code> dictionary.</p> parameter type description <code>min_significant</code> double Absolute tolerance for filtering. To disable filtering, set to <code>0</code>. <code>q</code> int Number of previous time steps that are reused. In a steady simulation, there are no previous time steps, so then the value is irrelevant."},{"location":"models.html#multi-vector","title":"Multi-vector","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.mv</code>. The abbreviation MV stands for multi-vector.</p> <p>In this model, differences are constructed similar to the least-squares model. However, it requires the approximation N^k to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface.</p> <p>Filtering can also be applied here, then (almost) linear columns in the matrix containing the input information from the current time step are removed. However, filtering is much less critical compared to the <code>LS</code> model as it concerns only the information from the current time step. If no filtering is wanted, the tolerance level should be set to zero.</p> <p>For more information refer to [3].</p> <p>The combination of this model with the coupled solver <code>CoupledSolverIQNI</code> corresponds to the IQN-MVJ from Lindner et al. [4], while using twice this model with the coupled solver <code>CoupledSolverIBQN</code> corresponds to the MVQN method developed by Bogaers et al. [5].</p> <p>The following parameter needs to be included in the <code>settings</code> dictionary.</p> parameter type description <code>min_significant</code> double (optional) Default: <code>0</code> (disabled). Absolute tolerance for filtering."},{"location":"models.html#multi-vector-matrix-free","title":"Multi-vector matrix-free","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.mvmf</code>. The abbreviation MV-MF stands for multi-vector matrix-free.</p> <p>By combining the QR-approach from the least-squares model with the time step wise storage of secant information, a matrix-free implementation of the multi-vector approach is obtained quite naturally. This implementation was also thought of by Spenke et al. [6] and is part of the IQN-ILSM framework [7].</p> <p>In this approach, the contribution of each time step is grouped into a separate term, where the most recent time step has priority over the later ones. Therefore, a parameter <code>q</code> is used to denote how many time steps are reused. Setting this parameter very large, this model will act the same as <code>MV</code>, which reuses all time steps. Generally, the performance will increase when this parameter is chosen larger, but so will be the computational cost. Nonetheless, this cost is much smaller compared to the non-matrix-free multi-vector approach.</p> <p>Filtering can be applied similar to the above described models, but this is typically not necessary.</p> <p>The following parameters need to be included in the <code>settings</code> dictionary.</p> parameter type description <code>min_significant</code> double (optional) Default: <code>0</code> (disabled). Absolute tolerance for filtering. <code>q</code> int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0."},{"location":"models.html#jacobian-approximation-from-surrogate-model","title":"Jacobian approximation from surrogate model","text":""},{"location":"models.html#surrogate","title":"Surrogate","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.surrogate</code>.</p> <p>Instead of relying on previously obtained input-output-pairs, this model uses a surrogate model to approximate the Jacobian. To achieve this a surrogate coupled calculation is performed at the start of every time step. From this calculation the Jacobian is extracted and used as approximation for the actual calculation. Besides the Jacobian, also the solution can be used as prediction for the actual calculation using the surrogate predictor. Once the actual calculation has converged, the surrogate can be synchronized with the actual solution. For more information refer to the <code>CoupledSolverIQNISM</code>.</p> <p>Beside the four methods shared by all models, this one has two additional important methods:</p> <ul> <li>The method <code>get_solution</code> starts the surrogate coupled calculation and returns the solution.</li> <li>The method <code>set_solution</code> allows to provide an interface solution that is used to perform one iteration (flow solver calculation and using result for structural solver calculation). In this way the surrogate can be synchronized with actual calculation. This method does not need to be implemented.</li> </ul> <p>The surrogate coupled calculation is performed with a <code>coupled_solver</code> that has its own <code>predictor</code>, <code>convergence_criterion</code>, <code>solver_wrappers</code> and coupling algorithm. The surrogate solver_wrappers should be cheaper to calculate, but still representative for the actual solver wrappers. For example, they might solve the same equations, but on a coarser mesh. Or, they might be a simplified 1D solver that can approximate the actual 2D or 3D simulation. Similarly, 2D surrogate solver wrappers can approximate a 3D calculation, for an axisymmetric case. For more details refer to [7].</p> <p>The following parameter needs to be included in the <code>settings</code> dictionary.</p> parameter type description <code>coupled_solver</code> dict Dictionary of the coupled solver used for the surrogate coupled calculation. The following parameter are not required in the <code>settings</code> of <code>coupled_solver</code>, as they are inherited from a higher component: <code>delta_t</code>, <code>save_restart</code>, <code>timestep_start</code>. The <code>case_name</code> parameter is set by default to <code>&lt;case_name&gt;_surrogate</code>, where <code>&lt;case_name&gt;</code> is the value of the <code>coupled_solver</code>, where this <code>surrogate</code> model is part of."},{"location":"models.html#mapped","title":"Mapped","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.mapped</code>.</p> <p>As a <code>surrogate</code> model usually won't have the same discretization as the actual solvers, mapping capabilities are provided. This special model acts analogously, to the <code>mapped</code> solver wrapper. It contains 3 <code>Components</code>: a mapper for the input, a real model and a mapper for the output.</p> parameter type description <code>mapper_interface_input</code> dict Interface input mapper. <code>mapper_interface_output</code> dict Interface output mapper. <code>surrogate</code> dict Dictionary of a model, e.g. <code>surrogate</code>."},{"location":"models.html#analytically-determined-jacobian","title":"Analytically determined Jacobian","text":"<p>Analytically determining the Jacobian is only possible for very simple solvers. One such <code>model</code> is available, that accomplishes this for the combination of the python tube flow solver and python tube structure solver. This code can also serve as example or template for the use of own analytically determined Jacobians.</p>"},{"location":"models.html#analytical-1d","title":"Analytical 1D","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.analytical_1d</code>. This <code>model</code> creates it own two <code>solver_wrappers</code> (<code>tube flow solver</code> and <code>tube structure solver</code>) that should be equal to the <code>solver_wrappers</code> used in the <code>coupled_solver</code>. A flow Jacobian and structure Jacobian are called from these <code>solver_wrappers</code> and combined to obtain the final Jacobian. For more information refer to [7].</p> <p>This Jacobian can be updated every iteration. Then the Jacobian will be determined in the current solution. Typically, however, this is not advised because the Jacobian doesn't change that much from iteration to iteration and because the computation of the Jacobian is rather expensive, as it involves explict matrix construction and storage as well as inversion of square dense matrices.</p> <p>The following parameters need to be included in the <code>settings</code> dictionary.</p> parameter type description <code>solver_models</code> list List of <code>solver_wrappers</code> to be used by the <code>model</code>: <code>tube flow solver</code> and <code>tube structure solver</code>. Normally these are equal to the ones used by the <code>coupled_solver</code>. <code>update_every_iteration</code> bool (optional) Default: <code>false</code>. Whether or not the Jacobian has to be recalculated every iteration (using the solution of the previous iteration)."},{"location":"models.html#restart","title":"Restart","text":"<p>The settings of a model may be changed upon restart. When increasing the reuse parameter <code>q</code>, the number of time steps stored will build up gradually until the final number is reached. Decreasing <code>q</code> occurs instantly.</p>"},{"location":"models.html#dummy-model","title":"Dummy model","text":"<p>The <code>type</code> for this model is <code>coupled_solvers.models.dummy_model</code>.</p> <p>This special dummy model can be used in a coupled solver that requires a secant or surrogate model, without the model actually performing any secant or surrogate calculation. (e.g. in CoupledSolverIQNISM) This model will not provide any (surrogate) Jacobian approximation nor surrogate solution if used as surrogate model.</p> <p>If the use of a dummy model is allowed, the <code>type</code> (<code>coupled_solvers.models.dummy_model</code>) can be written explicitly or omitted. No <code>settings</code> are required.</p>"},{"location":"models.html#references","title":"References","text":"<p>[1] Degroote J., Bathe K.-J. and Vierendeels J., \"Performance of a new partitioned procedure versus a monolithic procedure in fluid-structure interaction\", Computers &amp; Structures, vol. 87, no. 11\u201312, pp. 793-801, 2009.</p> <p>[2] Vierendeels J., Lanoye L., Degroote J. and Verdonck P., \"Implicit coupling of partitioned fluid-structure interaction problems with reduced order models\", Computers &amp; Structures, vol. 85, no. 11\u201314, pp. 970\u2013976, 2007.</p> <p>[3] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.</p> <p>[4] Lindner F., Mehl M., Scheufele K. and Uekermann B., \"A comparison of various quasi-Newton schemes for partitioned fluid-structure interaction\", in: B. Schrefler, E. O\u00f1ate, M. Papadrakakis (Eds.), 6th International Conference on Computational 975 Methods for Coupled Problems in Science and Engineering, pp. 477\u2013488, 2015.</p> <p>[5] Bogaers A., Kok S., Reddy B. and Franz T., \"Quasi-Newton methods for implicit black-box FSI coupling\", ComputerMethods in AppliedMechanics and Engineering, vol. 279, pp. 113\u2013132, 2014.</p> <p>[6] Spenke T., Hosters N. and Behr M., \"A multi-vector interface quasi-newton method with linear complexity for partitioned fluid\u2013structure interaction\", Computer Methods in Applied Mechanics and Engineering, vol. 361, pp. 112810, 2020.</p> <p>[7] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Surrogate-based acceleration of quasi-Newton techniques for fluid-structure interaction simulations\", Computers &amp; Structures, vol. 260, pp. 106720, 2022.</p> <p>[8] Delaiss\u00e9 N., Demeester T., Haelterman R. and Degroote J., \"Quasi-Newton methods for partitioned simulation of fluid-structure interaction reviewed in the generalized Broyden framework\", Archives of Computational Methods in Engineering, vol. 30, pp. 3271-3300, 2023.</p>"},{"location":"openfoam.html","title":"OpenFOAM","text":"<p>This is the documentation for all OpenFOAM solver wrappers. Currently, the use as the flow solver in FSI simulations is supported, no other multiphysics problems.</p>"},{"location":"openfoam.html#parameters","title":"Parameters","text":"<p>This section describes the parameters in the JSON file, listed in alphabetical order.</p> parameter type description <code>application</code> str Name of the (adapted) OpenFOAM-solver to be used for the flow problem. This name should start with <code>coconut_</code>. For OpenFOAM 11, only <code>coconut_foamRun</code> is possible. <code>boundary_names</code> list List of names of the patches corresponding to the interface. These names should match the patch names defined in the OpenFOAM-case. <code>compile_clean</code> bool (optional) Default: <code>false</code>. If set to true, the adapted application will first clean and then compile. <code>debug</code> bool (optional) Default: <code>false</code>. For every iteration, additional files are saved containing information on the input and output data of the solver. <code>delta_t</code> double Fixed timestep size in flow solver. <code>density</code> double (optional) Density of the fluid in an incompressible case. The density is multiplied with the kinematic pressure and traction. Required if an incompressible application is used, such as coconut_pimpleFoam. More information can be found here. <code>interface_input</code> dict List of dictionaries that describes the input <code>Interface</code>. This provides the  interface boundary conditions for the OpenFOAM solver. Each entry in the list has two keys: <code>model_part</code> and <code>variables</code>, with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the  <code>variables_dimensions</code> <code>dict</code> in  the file <code>coconut/data_structure/variables.py</code>. The model part name must be the concatenation of an entry from <code>boundary_names</code> and the string <code>_input</code>. <code>interface_output</code> dict Analogous to <code>interface_input</code>, but here the name must be the concatenation of an entry from <code>boundary_names</code> and the string <code>_output</code>. The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. <code>parallel</code> bool Set it to <code>true</code> if OpenFOAM solver is required to run in parallel. The required decomposition method and number of cores should be provided in the <code>&lt;case_directory&gt;/system/decomposeParDict</code> file. <code>print_coupling_convergence</code> bool (optional) Default <code>false</code>. If <code>true</code> and if the solver coupling convergence is checked, a statement is printed when the solver converges in the first solver iteration, see solver coupling convergence. <code>residual_variables</code> list (optional) A list containing OpenFOAM variables whose residuals you need to output. If provided, this will output the last initial residual of the pimple iterations for each FSI-coupling iteration in <code>&lt;case_directory&gt;/residuals.csv</code>. <code>time_precision</code> int Number of digits after the decimal sign to be used in the name of the time step directories which are made during execution. <code>timestep_start</code> int Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. <code>working_directory</code> str Directory where the OpenFOAM-case is defined (and which contains the JSON-file). <p><code>timestep_start</code> and <code>delta_t</code> are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used, and a warning is printed.</p>"},{"location":"openfoam.html#setting-up-a-new-case","title":"Setting up a new case","text":"<p>Following items should be present in the OpenFOAM-directory prior to launching CoCoNuT:</p> <ul> <li>The entire framework of the CFD-case in OpenFOAM which is to be used in the CoCoNuT simulation (so it should contain   the <code>constant</code> and <code>system</code> directory as well as the <code>0</code> directory). The working directory should be defined as if   you would like to run it as a CFD case. This <code>working directory</code> is defined in the JSON-file.</li> <li>The necessary parameters in the JSON-file containing the settings stipulated above.</li> </ul> <p>Following files are modified or used as a reference to create files by CoCoNuT, and must be included in the original OpenFOAM-directory:</p> <ul> <li><code>system/controlDict</code> with compulsory arguments:</li> </ul> key value <code>writeControl</code> <code>timeStep</code> <code>writeInterval</code> required write interval <code>writeFormat</code> <code>ascii</code> <code>timeFormat</code> <code>fixed</code> <code>timePrecision</code> required time precision based on <code>delta_t</code> (used in the names of time step folders) <code>runTimeModifiable</code> <code>false</code> <code>adjustTimeStep</code> <code>no</code> <ul> <li><code>constant/dynamicMeshDict</code> which contains the settings for OpenFOAM's dynamic motion solver</li> <li><code>system/decomposeParDict</code> with the necessary decomposition of the fluid domain (if <code>cores</code>&gt;1)</li> <li><code>0/pointDisplacement</code> with all the boundary conditions, including <code>fixedValue</code> boundary condition for the FSI   boundaries. This is used as a template for the <code>pointDisplacementTmp</code> to supply displacement boundary condition (   from structural solver) for the FSI-interface.</li> </ul>"},{"location":"openfoam.html#comments","title":"Comments","text":"<ul> <li>It is probably best to derive a new case from the directory containing an FSI simulation with OpenFOAM in <code>coconut/examples/</code> in order to copy its structure.</li> <li>For OpenFOAM 8, the applications like <code>pimpleFoam</code> need to be adapted to accommodate the communication with the solver wrapper during the FSI-simulation.   These adapted versions have the same name as the original OpenFOAM-solver but with the prefix <code>coconut_</code>.   If you do not use an OpenFOAM-application which is already converted for operation in CoCoNuT, you will have to convert the application yourself, see also this brief set of instructions.</li> <li>For OpenFOAM 11, only <code>foamRun</code> has been adapted but this solver can work with many solver modules (see OpenFOAM 11 documentation). </li> </ul>"},{"location":"openfoam.html#treatment-of-kinematic-pressure-and-traction","title":"Treatment of kinematic pressure and traction","text":"<p>If the OpenFOAM application is intended for incompressible flows, e.g. <code>pimpleFoam</code> (v8) or <code>incompressibleFluid</code> (v11), it solves the incompressible Navier-Stokes equations. As a consequence the pressure and traction (wallShearStress) values are kinematic and have the unit m\u00b2/s\u00b2. In order to couple these solvers to a structural solver, the pressure and traction are required to be expressed in Pa (kg/ms\u00b2).</p> <p>For these solvers, the <code>density</code> parameter is required in the JSON file and will be used to calculate the actual values from the kinematic ones. In case the OpenFOAM application is compressible, this correction is not required and the actual values in Pa are obtained directly.</p> <p>There is a third possibility. In some cases, the application solves the compressible equations obtaining an actual pressure, but the used momentumTransportModel is incompressible. It is the type of momentumTransportModel that determines whether the wallShearStress functionObject returns the kinematic or actual traction. In these cases, the density is not fixed and cannot simply be multiplied with the obtained kinematic values. Therefore, a new functionObject, rhoWallShearStress, is available, which is a modified version of wallShearStress and returns the actual traction, even if the momentumTransportModel is incompressible. Note that is this new functionObject is version specific, but common for all applications of one version. Upon compilation of the coconut application this functionObject is included in the binary. This was the case for, for example, coconut_interFoam and coconut_cavitatingFoam (OpenFOAM 8).</p> <p>The behaviour of CoCoNuT for these different applications is implemented in the solver wrapper itself, namely in the <code>kinematic_conversion_dict</code>, located in the files <code>vX.py</code>, with <code>X</code> the identifier of the OpenFOAM-version (e.g. <code>v10.py</code> for OpenFOAM 10). This means that when a new application is added, the behaviour for this new application should be specified in that location.</p>"},{"location":"openfoam.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The convergence criterion solver coupling convergence has been implemented for the OpenFOAM solver wrapper. Instead of comparing the different residuals (U, p, ...) with their respective tolerances before the first iteration, they are checked after the first iteration due to implementation restrictions. Note that OpenFOAM will always execute a final solver iteration after convergence. Depending on the settings, this final iteration may have different or no relaxation factors. Calling the solver twice with the same interface displacement, will not necessarily mean that the second call immediately converges. This is due to a (weak) nonlinearity in the calculation of the mesh deformation as a result of the explicit non-orthogonality correction in the normal gradient calculation used in the Laplacian equation. Attempts to use the option moveMeshOuterCorrectors (recalculating mesh motion in every solver iteration) showed that there exist problems with this feature: it disturbs the convergence checks and, when used in parallel, even causes the code to crash.</p>"},{"location":"openfoam.html#version-specific-documentation","title":"Version specific documentation","text":""},{"location":"openfoam.html#v10-openfoam-10","title":"v10 (OpenFOAM 10)","text":"<p>Base version. In this OpenFOAM version some changes were made with respect to OpenFOAM 8, and there are some changes in the case setup. The following list provides some but is not all extensive:</p> <ul> <li>The file <code>constant/transportProperties</code> has been renamed to <code>constant/physicalProperties</code>.</li> <li>The keyword <code>version</code> can be omitted from the header dictionary <code>FoamFile</code>.</li> <li>The dynamicMeshDict has been restructured, defining a <code>fvMeshMover</code> and removing the <code>dynamicFvMesh</code> class, see also the OpenFOAM documentation.</li> </ul>"},{"location":"openfoam.html#v11-openfoam-11","title":"v11 (OpenFOAM 11)","text":"<p>In this OpenFOAM version some changes were made with respect to OpenFOAM 10. The most prominent is the replacement of separate applications like <code>pimpleFoam</code> by a single solver <code>foamRun</code> which works with solver modules. The required changes for the OpenFOAM wrapper are visible in the version specific solver wrapper Python file <code>v11.py</code>.</p> <p>This is also reflected in the case setup:</p> <ul> <li>The application in <code>system/controlDict</code> is now foamRun and an additional keyword solver is required, such as <code>incompressibleFluid</code>.</li> </ul>"},{"location":"openfoam.html#details-on-the-openfoam-solver-wrapper","title":"Details on the OpenFOAM solver wrapper","text":""},{"location":"openfoam.html#communication-with-openfoam","title":"Communication with OpenFOAM","text":"<p>As with most other solver wrappers, the communication between the OpenFOAM code and the solver wrapper occurs  through the use of (empty) files with extension <code>.coco</code>. The OpenFOAM code checks for these message files in an infinite loop. When such file is detected, for example <code>continue.coco</code>,  the OpenFOAM code performs a certain action and creates a file <code>continue_ready.coco</code>. The solver wrapper is paused until it detects such a corresponding file.</p>"},{"location":"openfoam.html#clean-up-after-unexpected-stop","title":"Clean-up after unexpected stop","text":"<p>The aforementioned messaging procedure implies that OpenFOAM is constantly running during execution of the CoCoNuT-simulation. Exiting of the loop and closing of the program only occurs when the <code>stop.coco</code> is received. If an unexpected crash occurs, it can occasionally occur that the OpenFOAM processes are not ended properly  and that the user should take care to kill that OpenFOAM-loop manually (using <code>kill</code> or <code>pkill</code> in the Linux-terminal, e.g. <code>pkill coconut_*</code>).</p>"},{"location":"openfoam.html#the-solve_solution_step-method","title":"The <code>solve_solution_step</code> method","text":"<p>This method is the core of the simulation passing on the interface displacement to OpenFOAM and receiving the resulting loads (pressure and traction). The interface displacement is converted into an OpenFOAM-readable format (with the method <code>write_node_input</code>), by storing it in a <code>pointDisplacementTmp</code> field, which is read in by OpenFOAM in every iteration  (this required some adaptation of the solver, see next section).  Subsequently, the mesh is updated in OpenFOAM and the flow equations are solved. The dynamic mesh motion is handled by OpenFOAM itself. Finally, the method <code>read_node_output</code> is called in the solver wrapper, which reads the interface loads from the directory <code>postProcessing</code> (more precisely from the subdirectories <code>coconut_&lt;boundary_name&gt;</code>).</p>"},{"location":"openfoam.html#adapting-a-new-application-to-be-used-in-coconut-openfoam-10","title":"Adapting a new application to be used in CoCoNuT (OpenFOAM 10)","text":"<p>For OpenFOAM 10, the applications like <code>pimpleFoam</code> need to be adapted to accommodate the communications with the solver wrapper during the FSI-simulation. These adapted versions have the same name as the original OpenFOAM-solver but with the prefix <code>coconut_</code>. If you do not use an OpenFOAM-application which is already converted for operation in CoCoNuT, you will have to convert the application yourself. This can be done in a rather straightforward way by taking a look at already implemented application, for example <code>coconut_pimpleFoam</code>. In brief, the following steps should be undertaken:</p> <ul> <li>Some additional <code>include</code>-statements are needed: <code>fsiDisplacement.H</code>, <code>waitForSync.H</code> and <code>&lt;unistd.h&gt;</code>.   Also include <code>readCoconutControls.H</code> to create control variables used by CoCoNuT.</li> <li>Except for these initial <code>include</code>-statements, the entire solver code should be put in an infinite loop that starts   with <code>while (true)</code>. The code will stay in this loop and check with several conditional statements whether the solver wrapper in CoCoNuT has   sent a message to the OpenFOAM-solver.   These messages are sent by creating an empty file with a specific name in the OpenFOAM-directory.   The following file names should be checked by the OpenFOAM-solver: <code>next.coco</code>, <code>continue.coco</code>, <code>save.coco</code>, <code>stop.coco</code>.   To allow a pause of 1 ms between each loop the command usleep(1000) is used (which requires the line: <code>#include &lt;unistd.h&gt;</code> before the loop).</li> <li>Once such a message is received, the OpenFOAM code first executes a command to sync all processors (only important in a parallel run), for example <code>waitForSync(\"next\")</code>.   Details on this function are given here.</li> <li>If the file <code>next.coco</code> exists, a new time step is started.   Due to the fact that the infinite loop is driven by <code>while(true)</code> and not the default OpenFOAM-expression <code>while(runTime.run())</code>,    the statement <code>runTime.run();</code> has to be added.    This creates, initializes and calls the functionObjects in the <code>controlDict</code> file.   Furthermore, as in the original application, the runTime-object should be incremented, increasing the time step.</li> <li>If the file <code>continue.coco</code> exists, the interface has to be moved first, using the following lines:   <pre><code>forAll(boundaryNames, s)\n{\n    word boundaryName = boundaryNames[s];\n    ApplyFSIPointDisplacement(mesh, boundaryName);\n}\n</code></pre>   Thereafter, the flow equations need to be solved. This <code>if</code>-statement consequently contains   most of the original solver definition, in which the flow equations are called in the same order as in the original   CFD solver. Additionally, at the end of the PIMPLE corrector loop, the coupling convergence is checked, see solver coupling convergence.   Finally, at the end of this block the loads are written by calling the CoCoNuT functionObjects by including <code>executeCoconutFunctionObjects.H</code>.</li> <li>If the file <code>save.coco</code> exists, it is checked whether the flow fields should be stored in corresponding files according to the user-defined save interval by calling <code>runTime.write();</code>.</li> <li>If the file <code>stop.coco</code> exists, a <code>break</code>-statement should end the infinite loop and the OpenFOAM program terminates.</li> </ul> <p>The solver wrapper will automatically compile the adapted applications. This can also be done the default OpenFOAM-compilation method (loading the OpenFOAM-module and using <code>wmake</code> in the directory <code>solver_wrapper/coconut_&lt;solver_name&gt;</code>). To be able to compile the new application, the following files need to adapted.</p> <ul> <li>Update the file <code>Make/files</code> to have the correct application name and change the location of the executable to <code>$(FOAM_USER_APPBIN)</code>:   <pre><code>coconut_pimpleFoam.C\n\nEXE = $(FOAM_USER_APPBIN)/coconut_pimpleFoam\n</code></pre></li> <li>Update the file <code>Make/options</code> such that the CoCoNuT header files are found by adding the parent directory and its parent directory to the included files:   <pre><code>EXE_INC = \\\n  -I.. \\\n  -I../.. \\\n  -I&lt;INSERT OTHER LOCATIONS&gt;\n</code></pre></li> </ul>"},{"location":"openfoam.html#the-waitforsync-command","title":"The waitForSync command","text":"<p>This command, for example <code>waitForSync(\"next\")</code>, is called at the start of every message block and is required to avoid that one processor goes through the block and already removes the message file before all others have seen it. This is achieved by gathering a label on all processors, effectively syncing them. After they are synced, the message file is removed and the corresponding ready message is written, for example <code>next_ready.coco</code>. Thereafter, they are synced once more. This avoids that while removing the file, one processor has left and again entered the same block. Note that the solver wrapper already receives the return message, for example <code>next_ready.coco</code>, before the completion of the block. This results in a speed-up, but requires the solver wrapper to check if, for example, the loads have been fully written before reading them.</p>"},{"location":"openfoam.html#disclaimer","title":"Disclaimer","text":"<p>This offering is not approved or endorsed by OpenCFD Limited, producer and distributor of the OpenFOAM software via www.openfoam.com, and owner of the OPENFOAM\u00ae and OpenCFD\u00ae trademarks, nor by OpenFOAM Foundation Limited, producer and distributor of the OpenFOAM software via www.openfoam.org.</p>"},{"location":"post_processing.html","title":"Post-processing","text":"<p>As described in the coupled solver documentation, a pickle file can be saved to store details on the computation. This includes</p> <ul> <li>solution data on the interface, </li> <li>position of the data points on the interface, </li> <li>details on the convergence behaviour, such as number of coupling iterations and coupling residuals,</li> <li>distribution of the elapsed simulation time,</li> <li>and history of the simulation, such as restarts.</li> </ul> <p>This information can be accessed by loading the pickle file, for example for a file <code>case_results.pickle</code>: <pre><code>import pickle\nwith open('case_results.pickle', 'rb') as f:\n    data = pickle.load(f)\n</code></pre></p> <p>Nevertheless, CoCoNuT also provides a more user-friendly tool to visualize and inspect this information.</p>"},{"location":"post_processing.html#the-class-postprocess","title":"The class PostProcess","text":"<p>Instead of loading the pickle file directly, its path can be used to create an instance of the <code>PostProcess</code> class. <pre><code>from coconut.examples.post_processing.post_processing import *\npp = PostProcess('case_results.pickle')\n</code></pre></p> <p>Info</p> <p>The example code in this document has been created for the <code>tube/openfoam3d_kratos_structure3d</code> example.</p> <p>Printing this class provides an overview of the simulation, for example <pre><code>print(pp)\n</code></pre> will output a statement analogous to <pre><code>PostProcess of pickle file case_results.pickle\nContaining 100 time steps with size 0.0001s\nCoupling\n    interface \"interface_x\" consisting of\n        model part \"mantle_input\" with variables\n            displacement (vector)\n    interface \"interface_y\" consisting of\n        model part \"mantle_output\" with variables\n            pressure (scalar)\n            traction (vector)\n</code></pre></p> <p>Among the methods of this class are:</p> <ul> <li> <p>The method <code>print_summary()</code> prints a summary of the elapsed simulation time and its distribution over the different components, similar to the summary outputted at the end of a simulation.</p> <pre><code>pp.print_summary()\n</code></pre> </li> <li> <p>The method <code>print_info()</code> prints information on when the simulation was started and if it was restarted as well as on which machine it has been run.</p> <pre><code>pp.print_info()\n</code></pre> </li> <li> <p>The method <code>get_data()</code> returns a copy of the data in the pickle file.</p> </li> <li> <p>The method <code>get_residual_history()</code> returns a copy of the list of coupling residuals (nested list, which contains for each time step a list of the coupling residuals of that time step).</p> </li> <li> <p>The method <code>get_coupling_iterations()</code> returns a copy of the list of the number of coupling iterations per time step.</p> </li> <li> <p>The method  <code>add_subset(**kwargs)</code> allows to create and add a subset of selected points and/or time steps.     This will prove useful for extracting data and making plots or animations.     It requires several keyword arguments as detailed by the <code>SubSet</code> documentation.     Multiple <code>SubSets</code> can be added.     A list containing the added <code>SubSets</code> can be accessed through the <code>get_subsets()</code> method.</p> </li> </ul>"},{"location":"post_processing.html#the-class-subset","title":"The class SubSet","text":"<p>A <code>SubSet</code> is always added to a <code>PostProcess</code> instance and is used to select particular points and/or time steps. A <code>SubSet</code> needs to be defined on a single interface and model part. The selection of points thus needs to be within a single model part. If points from multiple model parts are required, multiple <code>SubSets</code> have to be added.</p> <p>If our example above only has one model part for both the x- and y-interface, this might be done as follows. <pre><code>sx = pp.add_subset(interface='interface_x')\nsy = pp.add_subset(interface='interface_y')\n</code></pre> <code>'interface_x'</code> and <code>'interface_y'</code> refer to the input and output interface of the first solver, respectively. The first solver is typically the flow solver such that <code>'interface_x'</code> contains displacement values  and <code>'interface_y'</code> contains pressure and traction values.</p> <p>The interfaces of the second solver are not accessible, since they are not stored!</p> <p>If in our examples, there would have been multiple model parts, an error would have been raised when adding the subset, because the declaration is ambiguous. In that case, the model part would also have to be specified. The full set of possible arguments is given below.</p> keyword argument type/value description <code>interface</code> <code>'interface_x'</code> or <code>'interface_y'</code> (optional) Indicates whether the <code>SubSet</code> is created on the input interface of the first solver (<code>'interface_x'</code>) or the output interface of the first solver (<code>'interface_y'</code>). Note that a <code>SubSet</code> cannot be defined with multiple interfaces! <code>model_part</code> str (optional) Chooses the model part from which the <code>SubSet</code> is created. Note that a <code>SubSet</code> cannot be defined with multiple model parts! The model part names of a <code>PostProcess</code> instance can be accessed with the method \u00b4get_model_part_names()\u00b4. <code>variable</code> str (optional) Selects the variable of which data needs to be outputted for the selected points and time step. These are the calculation variables specified in the JSON file, plus the variable <code>'coordinates'</code>. For example <code>'displacement'</code>, <code>'pressure'</code>, <code>'traction'</code>. <code>component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> (optional) Selects the component of the variable that needs ot be outputted in case of a vector variable. <code>0</code>, <code>1</code> and <code>2</code> correspond to  <code>'x'</code>, <code>'y'</code>and <code>'z'</code>, respectively. <code>sort</code> tuple (optional) Default: <code>(0, 1, 2)</code>. Priority for ordering points. By default, the points are ordered first by x-coordinate, then y-coordinate and finally z-coordinate. <p>While the interface and model part cannot be changed once the <code>SubSet</code> is created, the variable and component can be modified on the fly.</p>"},{"location":"post_processing.html#selecting-points","title":"Selecting points","text":"<p>To make a selection of points the method <code>select_points(p_mask)</code> is used, where <code>p_mask</code> is a one-dimensional numpy-array containing boolean values and with a length equal to the number of points in the model part. A <code>True</code> value selects the corresponding point, whereas a <code>False</code> value deselects it.</p> <p>The recommended approach is using inequalities on the output of <code>get_initial_coordinates()</code>, which returns a two-dimensional array, where the rows are the points and the three columns correspond to the three components, x, y and z, respectively. The following example selects points with a z-coordinate close to zero and a positive y-component. <pre><code>initial_coordinates = sx.get_all_initial_coordinates()\nmask1 = abs(initial_coordinates[:, 2]) &lt; 0.0005\nmask2 = initial_coordinates[:, 1] &gt; 0\nsx.select_points(mask1 &amp; mask2)\n\ninitial_coordinates = sy.get_all_initial_coordinates()\nmask1 = (initial_coordinates[:, 2] &gt; 0) &amp; (initial_coordinates[:, 2] &lt; 0.0005) # (1)!\nmask2 = initial_coordinates[:, 1] &gt; 0\nsy.select_points(mask1 &amp; mask2)\n</code></pre></p> <ol> <li>The specific inequalities in which the points are selected are case specific. Here for example, the points on the <code>y-interface</code> are not located exactly on the xy-plane, but just next to it. The points with a positive z-coordinate close to zero are selected.</li> </ol> <p>These methods are also useful:</p> <ul> <li><code>get_size()</code> returns the size of the selection,</li> <li><code>get_initial_coordinates_selection()</code> returns the initial coordinates of the selection,</li> <li><code>reset_points_selection()</code> undoes point selection, in other words, selects all points.</li> </ul>"},{"location":"post_processing.html#selecting-times","title":"Selecting times","text":"<p>The selection time steps occurs analogously to selection of points. The following methods are available:</p> <ul> <li><code>select_times(t_mask)</code> selects time step based on a boolean mask with length equal to the number of time steps plus one to account for the initial time value,</li> <li><code>get_all_times()</code> returns a one-dimensional array with all time instances,</li> <li><code>get_all_steps()</code> returns a one-dimensional array with all time steps numbers (for example <code>[0, 1, 2, ...]</code>),</li> <li><code>get_num_steps()</code> returns the size of the selection,</li> <li><code>get_times_selection()</code> returns the time instances of the selection,</li> <li><code>get_steps_selection()</code> returns the time step numbers of the selection,</li> <li><code>reset_times_selection()</code> undoes time selection, in other words, selects all time instances.</li> </ul>"},{"location":"post_processing.html#getting-solution-data","title":"Getting solution data","text":"<p>Once the desired points and time steps have been selected, the solution data can be accessed with the method <code>get_values(**kwargs)</code>. The possible arguments are:</p> keyword argument type/value description <code>variable</code> str (optional) Selects the variable of which data needs to be outputted for the selected points and time step. These are the calculation variables specified in the JSON file, plus the variable <code>'coordinates'</code>. For example <code>'displacement'</code>, <code>'pressure'</code>, <code>'traction'</code>. <code>component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> (optional) If not present, all available components are returned. Selects the component of the variable that needs ot be outputted in case of a vector variable. <code>0</code>, <code>1</code> and <code>2</code> correspond to  <code>'x'</code>, <code>'y'</code>and <code>'z'</code>, respectively. <p>If no variable argument is provided, the previously set value is used. If there was no variable set earlier and more than one is available, an error is raised to point the user to the ambiguity.</p> <p>Tip</p> <p>The available variables can be accessed through the method <code>get_available_variables()</code>.</p> <p>For vector variables, without specifying a component, the output of this method is a three-dimensional numpy array, where</p> <ul> <li>the first axis corresponds to the time step,</li> <li>the second axis to the points,</li> <li>and the third to the component.</li> </ul> <p>For scalar variables or when a component is specified, the output is a two-dimensional numpy array, where</p> <ul> <li>the first axis corresponds to the time step,</li> <li>the second axis to the points.</li> </ul> <p>In our example, we can get the x- and y- coordinates of the selected points as follows <pre><code>x_coordinates = sx.get_values('coordinates', 'x')\ny_coordinates = sx.get_values(component='y')\n</code></pre> or get the pressure values with <pre><code>pressure = sy.get_values('pressure')\n</code></pre></p>"},{"location":"post_processing.html#visualization","title":"Visualization","text":"<p>With the classes above, custom data analyses or visualizations are possible. However, CoCoNuT also offers built-in tools for the most common visualizations.</p> <p>For different types of visualization, different classes are available in \u00b4post_processing.py\u00b4. A distinction is made between, on the one hand,</p> <ul> <li>an Animation (moving in time),</li> <li>or a Plot (static),</li> </ul> <p>and, on the other hand,</p> <ul> <li>2d (for example, y-displacement in function of x-coordinate)</li> <li>or 3d (plotting points in 3d space).</li> </ul>"},{"location":"post_processing.html#quick-guide-to-visualizations","title":"Quick guide to visualizations","text":"<p>The quickest way to create a visualization is through the pre-made classes. These require a (collection of) <code>SubSet</code> and in some cases the components of the variables to show. In our example, the y-displacement of the selected points can be animated in function of the initial x-coordinate as follows <pre><code>Animation2dDisplacement(sx, x_component='x', y_component='y')\n</code></pre></p> <p></p> <p>Success</p> <p>Don't forget to add <code>plt.show()</code> at the end to show the plot(s) or animation(s).</p> <p>Tip</p> <p>In these pre-made classes, a <code>PostProcess</code> instance can be provided directly as subset. All model parts of this <code>PostProcess</code> instance will be automatically added to the visualization.</p> <p>Two-dimensional animations show one variable on the ordinate (y-axis) in function of a variable on the abscissa (x-axis).</p> <ul> <li><code>Animation2dDisplacement(subset, x_component, y_component)</code>: animates <code>y-component</code> of the displacement in function of the <code>x-component</code> of the initial coordinates.</li> <li><code>Animation2dCoordinates(subset, x_component, y_component)</code>: animates <code>y-component</code> of the instantaneous coordinates in function of the <code>x-component</code> of the instantaneous coordinates.</li> <li><code>Animation2dPressure(subset, x_component)</code>: animates pressure in function of the <code>x-component</code> of the initial coordinates.</li> <li><code>Animation2dTraction(subset, x_component, y_component)</code>: animates <code>y-component</code> of the traction in function of the <code>x-component</code> of the initial coordinates.</li> </ul> <p>Replacing the word Animate with Plot, Two-dimensional plots are completely analogous, but are typically used to only show one time instance. This can be selected when creating the <code>SubSet</code>, or on the fly with the keyword arguments <code>time_step</code> (time step number) or <code>time</code> (time in seconds). Only one of these parameters should be provided. In our example, the pressure can be plotted at time 0.001 s. <pre><code>Plot2dPressure(sy, x_component='x', time=0.001) # (1)!\n</code></pre></p> <ol> <li>If the time step is 0.0001 s, for example, this is identical to the argument <code>time_step=10</code>.</li> </ol> <p></p> <p>Three-dimensional animations show the coordinates of points and possibly color them by a variable. Instantaneous coordinates are used when available colors, otherwise initial coordinates are used.</p> When are instantaneous coordinates available? <p>Instantaneous coordinates are only available for interfaces that have the displacement variables. This is typically <code>interface_x</code>. For other interfaces, only the initial coordinates are available.</p> <ul> <li><code>Animation3dDisplacement(subset)</code>: animates the instantaneous coordinates and colors the points by magnitude of displacement.</li> <li><code>Animation3dCoordinates(subset)</code>: animates the instantaneous coordinates without coloring.</li> <li><code>Animation3dPressure(subset)</code>: animates the initial coordinates and colors the points by pressure values.</li> <li><code>Animation3dTraction(subset)</code>: animates the instantaneous coordinates and colors the points by magnitude of traction.</li> </ul> <p>If the variable by which the points are colored is a vector, also one of the components can be used instead of the magnitude by including the keyword argument <code>component</code>. For example to animate the z-component of displacement: <pre><code>Animation3dDisplacement(pp, component='z') # (1)!\n</code></pre></p> <ol> <li>Here a <code>PostProcess</code> instance is used, instead of a <code>SubSet</code>. This is only possible for the pre-made classes presented in this section.</li> </ol> <p></p> <p>Again Three-dimensional plots are analogous replacing the word Animate with Plot and optionally adding the keyword argument <code>time_step</code> or <code>time</code>.s</p>"},{"location":"post_processing.html#saving-figures","title":"Saving figures","text":"<p>The method <code>save(file_path)</code> can be used to store the plot or animations. If no <code>file_path</code> is provided, the <code>figure_name</code> is used with extension <code>.png</code> for plots and <code>.gif</code> for animations.</p> <p>By default, for saving animations, the Matplotlib writer PillowWriter is used: <pre><code>writer = ani.PillowWriter(fps=15, metadata=dict(artist='CoCoNuT'), bitrate=1800)\n</code></pre> This can be overwritten with the method <code>set_writer(writer)</code>.</p>"},{"location":"post_processing.html#complete-guide-to-visualizations","title":"Complete guide to visualizations","text":"<p>The pre-made classes discussed above are in fact child classes of the classes <code>Animation</code>, <code>Plot</code>, <code>Figure2d</code> and <code>Figure3d</code>, in which several parameters are pre-set.</p> <p>The required positional argument is <code>subset</code>.</p> argument type description <code>subset</code> <code>SubSet</code> or collection (list, tuple, ...) of SubSets <code>Subset(s)</code> to be shown in the figure. <p>For two-dimensional figures (<code>Figure2d</code>), there are two additional required positional arguments.</p> argument type description <code>x_variable</code> str The variable to be shown on the abscissa (x-axis). <code>y_variable</code> str The variable to be shown on the ordinate (y-axis). <p>These variables are the calculation variables specified in the JSON file, plus the variable <code>'coordinates'</code> and <code>'initial_coordinates'</code>. For example <code>'displacement'</code>, <code>'pressure'</code>, <code>'traction'</code>.</p> <p>Furthermore, there are several optional keyword arguments that apply to all <code>Figures</code>.</p> keyword argument type/value description <code>figure_name</code> str (optional) Name of the figure, shown as title of the plot window. Default is the class name. This name has to be unique. If a figure with the provided name exists, a number will automatically be appended. <code>aspect</code> <code>'auto'</code> or <code>'aspect'</code> (optional) If <code>'auto'</code> (default for 2d), the axis scaling of the axes is chosen to fill the plot window. If `'aspect' (default for 3d), alle axes are scaled in the same way. <code>print_function</code> <code>False</code> or function (optional) If not provided, the time is printed. Use <code>False</code> to disable or provide a custom function which receives time as single argument and returns a string. <code>text_box_style</code> dict (optional) Dictionary with settings determining the text box style. Default: <code>dict(facecolor='silver', edgecolor='black', pad=5.0, alpha=0.5)</code> <code>text_location</code> tuple of two floats (optional) Window coordinates of the text box. Default: for 2d <code>(0.1, 0.1)</code>, for 3d <code>(0, 0)</code>. <code>name</code> str or collection of str (optional) Name(s) of the <code>SubSet(s)</code> used in the legend and to identify the <code>SubSet</code>. If not provided, the <code>case_name</code> of the simulation appended by the model part name is used. If a collection of <code>SubSets</code> is provided: the value can be a single string, which will be appended with a number, or a collections of strings with the same length. This name is used to identify SubSets and has to be unique. Therefore, a number will appended if this is not the case. <p>Finally, there are keyword arguments that are specific to a type of class.</p> <p>For two-dimensional figures (<code>Figure2d</code>), there are two optional keyword arguments.</p> keyword argument type/value description <code>x_component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> Required if <code>x_variable</code> is not scalar. Selects the component of the variable that needs to be shown on the abscissa (x-axis). <code>y_component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> Required if <code>y_variable</code> is not scalar. Selects the component of the variable that needs to be shown on the ordinate (y-axis). <p><code>0</code>, <code>1</code> and <code>2</code> correspond to  <code>'x'</code>, <code>'y'</code>and <code>'z'</code>, respectively.</p> <p>For three-dimensional figures (<code>Figure3d</code>), there are three optional keyword arguments.</p> keyword argument type/value description <code>variable</code> <code>'coordinates'</code> or <code>'initial_coordinates'</code> (optional) Determines whether instantaneous or initial coordinates are shown. Default: instantaneous coordinates when available, otherwise initial coordinates. <code>color_by</code> str (optional) Variable by which the points are colored. These variables are the calculation variables specified in the JSON file, plus the variable <code>'coordinates'</code>. If not provided, no coloring is done. <code>component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> (optional) Component of the <code>color_by</code> variable used for coloring the points. If not provided while <code>color_by</code> is a vector variable, the magnitude is used for coloring. <p>For plots (<code>Plot</code>), there are two optional keyword arguments.</p> keyword argument type description <code>time_step</code> int (optional) Time step number of the data to be shown. If not provided, while the <code>SubSet</code> contains more than one time instance, the initial time step is used. <code>time</code> float (optional) Time (in seconds) of the data to be shown. If not provided, while the <code>SubSet</code> contains more than one time instance, the initial time step is used. <p>Either <code>time_step</code> or <code>time</code> should be provided. If both are present, <code>time</code> is ignored. The <code>time_step</code> or <code>time</code> can be set using the methods <code>set_time_step(time_step)</code> or <code>set_time(time)</code>. For the former, also see Adding multiple subsets when subsets are added with multiple time step sizes. </p> <p>For animations (<code>Animation</code>), there is one optional keyword argument.</p> keyword argument type description <code>func_animation_setting</code> dict (optional) Dictionary with settings relating to the animation. For details see the Matplotlib documentation. <p>A non-extensive overview is shown below:</p> setting type default description <code>frames</code> int or range all available time steps skipping according to <code>skip</code> Determines which time steps are shown. Also see Adding multiple subsets when subsets are added with multiple time step sizes. If range, the sequence of time steps to be shown. If int, the number of time steps to be shown starting from the initial time step, skipping according to <code>skip</code>. If not provided all time steps are shown,skipping according to <code>skip</code> <code>skip</code> int <code>0</code> Determines how many time steps are skipped between each shown frame, for example to show 1 time step every 10, use 9. Also see Adding multiple subsets when subsets are added with multiple time step sizes.  Only used if <code>frames</code> is not provided or if <code>frames</code> is an int. This useful to speed up the animation. <code>save_count</code> int number of frames Numbers of frames to cache. <code>interval</code> int <code>200</code> Delay between frames in milliseconds. Increase to obtain a slower playing speed. <code>repeat</code> bool <code>True</code> Whether the animation repeats when the sequence of frames is completed. Blitting is not supported. <p>Blitting is an approach to optimize drawing by rendering all non-changing graphic elements into a background image once.</p> <p>For example, to animate the displacement as before, but only show one time step every five, for the first 50: <pre><code>Animation2dDisplacement(sx, x_component='x', y_component='y',  func_animation_settings=dict(frames=50, skip=4))\n</code></pre></p> <p>or equivalently</p> <pre><code>Animation2d(sx, 'initial_coordinates', 'displacement', x_component='x', y_component='y',  func_animation_settings=dict(frames=50, skip=4))\n</code></pre> <p>Tip</p> <p>To change these animations settings after initialization, you case use the method <code>set_func_animation_settings()</code>: <pre><code>displacement_animation = Animation2dDisplacement(sx, x_component='x', y_component='y')\ndisplacement_animation.set_func_animation_settings(repeat=False, frames=10)\n</code></pre></p> <p></p> <p>Tip</p> <p>If the warning is raised that animations are deleted before rendering. Assigning the animations to a variable: <pre><code>pressure_animation = Animation3dPressure(pp)\n</code></pre></p>"},{"location":"post_processing.html#changing-the-figure-layout","title":"Changing the figure layout","text":"<p>The plots and animations shown above use default coloring, markers, line thickness, ... Different options to customize these can be found in Matplotlib documentation. Here it is explained how these methods can be used together with CoCoNuT visualizations.</p> <p>To change aspects related to the whole figure such as labels, titles, the legend, ticks or the grid, there are two ways in Matplotlib.</p> <ol> <li> <p>By using the object-oriented style</p> <pre><code>pressure_animation.get_ax().set_title('Pressure animation')\npressure_animation.get_figure().tight_layout()\n</code></pre> </li> <li> <p>or the pyplot-style, where the figure has to be made active first.</p> <pre><code>pressure_animation.make_active()\nplt.title('Pressure animation')\nplt.tight_layout()\n</code></pre> </li> </ol> <p></p> <p>The methods that can be used towards this end are:</p> <ul> <li><code>get_figure()</code>: returns the Matplotlib Figure,</li> <li><code>get_figure_name()</code>: returns the figure name,</li> <li><code>get_ax()</code>: returns the Matplotlib Axes,</li> <li><code>make_active()</code>: makes the figure active to use the pyplot-style approach.</li> </ul> <p>To style artists, the <code>line</code> objects need to be accessed in 2d and the <code>scatter</code> objects in 3d. This way, color, linewidth, linestyle, marker, markersize and more can be adjusted.</p> <p>The method that can be used for this are, for 2d:</p> <ul> <li><code>get_lines()</code>: returns a list of the lines that have been added,</li> <li><code>get_line(name)</code>: returns the line corresponding to the <code>SubSet</code> with name <code>name</code> or if <code>name</code> is an int, the <code>SubSet</code> corresponding to that index,</li> </ul> <p>and for 3d:</p> <ul> <li><code>get_scatters()</code>: returns a list of the scatters that have been added,</li> <li><code>get_scatter(name)</code>: returns the scatter corresponding to the <code>SubSet</code> with name <code>name</code> or if <code>name</code> is an int, the <code>SubSet</code> corresponding to that index.</li> </ul> <p>In the example below, a cross-section on the yz-plane is shown, without line but with circular green markers. Moreover, the axis labels are updated to include units. <pre><code>sx2 = pp.add_subset(interface='interface_x')\nsx2.select_points(abs(sx2.get_all_initial_coordinates()[:, 0]) &lt; 0.0005)\ncoordinates_animation = Animation2dCoordinates(sx2, x_component='z', y_component='y', name='yz')\n\nline = coordinates_animation.get_line('yz')\nline.set(color='green', linestyle='', marker='o', markersize=5)\nax = coordinates_animation.get_ax()\nax.set_xlabel('z coordinates (m)')\nax.set_ylabel('y coordinates (m)')\n</code></pre></p> <p></p> <p>Finally, for animations, the Matplotlib Funcanimation object can be accessed through the method <code>get_animation()</code>.</p>"},{"location":"post_processing.html#adding-multiple-subsets","title":"Adding multiple SubSets","text":"<p>Up to now, a figure was initialized with one or more <code>SubSets</code>. However, it is also possible to add a <code>SubSet</code> to an existing figure with the method <code>add_subset(subset)</code>, which accepts analogous keyword arguments.</p> <p>Other useful methods are:</p> <ul> <li><code>get_subsets()</code>: returns a list of the <code>SubSets</code> that have been added,</li> <li><code>get_subset(name)</code>: returns the <code>SubSet</code> with name <code>name</code> or if <code>name</code> is an int, the <code>SubSet</code> corresponding to that index,</li> <li><code>remove_subset(name)</code>: removes the <code>SubSet</code> with name <code>name</code> or if <code>name</code> is an int, the <code>SubSet</code> corresponding to that index,</li> <li><code>get_subset_names()</code>: returns a list of the names of the added <code>SubSets</code>,</li> </ul> <p>Also <code>SubSets</code> with different time step sizes can be added to a single figure. The different time step sizes will automatically be taken into account by internally working with the smallest matching time step size. For example, when two <code>SubSets</code> with time step size 0.3 s and 0.2 s are added, the internal time step size will be 0.1 s. This is important when setting or changing the <code>time step</code> parameter for a plot or the <code>frames</code> or <code>skip</code> parameters for an animation. The values that have to be used are the ones corresponding to the smallest matching time step size at that moment.</p> <p>Tip</p> <p>By printing an instance of the classes described here, a summary is provided of what is shown. For example: <pre><code>print(coordinates_animation)\n</code></pre></p>"},{"location":"post_processing.html#time-evolution","title":"Time evolution","text":"<p>To plot the time evolution of a variable, a special class <code>TimeEvolution</code> exists. This class is different from the ones previously mentioned since it has time on the abscissa (x-axis). It requires both a <code>SubSet</code> with a single point and a variable to be initialized.</p> argument type description <code>subset</code> <code>SubSet</code> or collection (list, tuple, ...) of SubSets <code>Subset(s)</code> to be shown in the figure, which must contain one point. <code>variable</code> str The variable to be shown on the ordinate (y-axis). These variables are the calculation variables specified in the JSON file, plus the variable <code>'coordinates'</code>. For example <code>'displacement'</code>, <code>'pressure'</code>, <code>'traction'</code>. <p>With the optional keyword argument <code>component</code>, a component can be selected.</p> argument type description <code>component</code> <code>'x'</code>, <code>'y'</code>, <code>'z'</code>, <code>0</code>, <code>1</code> or <code>2</code> (optional) Selects the component of the variable that needs to be shown. If not provided, the magnitude is shown. <p>The keyword arguments <code>figure_name</code>, <code>aspect</code> and <code>name</code> can also be used, in the same way as for visualizations. Saving, changing the figure layout and adding multiple SubSets are done in the same way, as well.</p> <p>Experimental</p> <p>When the debug mode is activated in the coupled_solver, the solution data is stored every coupling iteration and also interface residual data is stored. The post-processing is not (yet) compatible with this mode.</p>"},{"location":"predictors.html","title":"Predictors","text":"<p>This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The predictors differ in the number of previous time steps they take into account and the polynomial degree that is used. Additionally, there is one special type that uses a surrogate model. The formulas in this document, use the index n to refer to the time step, where n+1 is the current time step, i.e. the time step for which the initial guess is made. The vector x is the input for the first solver, conform the coupled solvers' documentation.</p> <p>A predictor is intialized in the coupled solver using an initial solution as determined by the coupled solver. As such, there is at least one previous solution available.</p> <p>For the polynomial predictors, the <code>predictor</code> dictionary only requires a <code>type</code> (e.g. <code>predictors.linear</code>) in the JSON file, no <code>settings</code> dictionary has to be provided.</p> <p>Specification of a predictor is mandatory, also for a steady simulation. In that case, however, it does not matter which predictor is chosen as only one \"time step\" is performed.</p>"},{"location":"predictors.html#constant","title":"Constant","text":"<p>The <code>type</code> for this predictor is <code>predictors.constant</code>. This predictor uses the result from the previous solution as the initial guess in the current time step: $$ x^{n+1}=x^{n}. $$</p>"},{"location":"predictors.html#linear","title":"Linear","text":"<p>The <code>type</code> for this predictor is <code>predictors.linear</code>. This predictor uses the results from the last two time steps to determine the initial guess in the current time step  using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used, i.e. the predictor <code>PredictorConstant</code>.</p>"},{"location":"predictors.html#legacy","title":"Legacy","text":"<p>The <code>type</code> for this predictor is <code>predictors.legacy</code>. This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor <code>PredictorLinear</code> is used. This predictor is called <code>PredictorLegacy</code> as it corresponds to the second order extrapolator in the coupling code Tango, the predecessor of CoCoNuT.</p>"},{"location":"predictors.html#quadratic","title":"Quadratic","text":"<p>The <code>type</code> for this predictor is <code>predictors.quadratic</code>. This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor <code>PredictorLinear</code> is used.</p>"},{"location":"predictors.html#cubic","title":"Cubic","text":"<p>The <code>type</code> for this predictor is <code>predictors.cubic</code>. This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor <code>PredictorQuadratic</code> is used.</p>"},{"location":"predictors.html#surrogate","title":"Surrogate","text":"<p>The <code>type</code> for this predictor is <code>predictors.surrogate</code>.</p> <p>The following parameters may be included in the <code>settings</code> dictionary.</p> <p>This predictor requires that a <code>surrogate</code> model is used in the coupled solver <code>CoupledSolverIQNISM</code> (defined in the settings of the coupled solver). Moreover, this <code>surrogate</code> model must provide a surrogate solution, which is used to update the values in this predictor.</p> <p>There are two options available:</p> <ul> <li>The surrogate solution can be used directly: $$ x^{n+1}=x_s^{n+1}, $$ where x_s^{n+1} is the surrogate solution of the current time step.</li> <li>Or the change in surrogate solution can be used: $$ x^{n+1}=x^{n} + (x_s^{n+1} - x_s^{n}), $$ where x_s is the surrogate solution, and the superscript n+1 and n indicate the current and previous time steps, respectively.</li> </ul> <p>The following parameters need to be included in the <code>settings</code> dictionary.</p> parameter type description <code>predict_change</code> dict (optional) Default: <code>true</code>. Indicates it the change in surrogate solution should be used. If <code>false</code>, the surrogate solution serves as prediction directly."},{"location":"predictors.html#restart","title":"Restart","text":"<p>Upon restart, the predictor may be changed. When changing an extrapolator (Constant, Linear, Quadratic, Legacy and Cubic) to a higher order, the first extrapolation will still be of the original order, but the order will increase with each time step until the new order is reached, just like at the start of a simulation. Changing to a lower order has direct effect.</p> <p>No information is transferred when switching from or to a surrogate predictor.</p>"},{"location":"predictors.html#dummy-predictor","title":"Dummy predictor","text":"<p>This dummy predictor can be used in the one-way coupled solvers, which doesn't require a predictor.</p> <p>If the use of a dummy predictor is allowed, the <code>type</code> (<code>convergence_criteria.dummy_convergence_criterion</code>) can be written explicitly or omitted. No <code>settings</code> are required. Note that the key <code>predictor</code> is still required.</p>"},{"location":"python.html","title":"Python","text":"<p>This is the documentation for all Python solver wrappers. Currently, only solvers exist for the one-dimensional (1D) calculation of a straight flexible tube.</p>"},{"location":"python.html#tube","title":"Tube","text":"<p>There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in <code>m</code> intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the <code>m</code> cells.</p> <p>There is one flow solver <code>SolverWrapperTubeFlow</code> and two structural solvers, one with inertia <code>SolverWrapperTubeStructure</code> and one without <code>SolverWrapperTubeRingmodel</code>. These solvers are very simple and provide insight in the physics, especially in the stability of fluid-structure interaction simulation. Nonetheless, they are not meant to provide an accurate representation of reality. Especially the pressure stabilization term in the flow solver smooths the pressure distribution.</p>"},{"location":"python.html#settings","title":"Settings","text":"<p>The following parameters, listed in alphabetical order, need to be provided in the main JSON parameter file as <code>settings</code> of the solver wrapper.</p> parameter type description <code>debug</code> bool (optional) Default: <code>false</code>. For every iteration, text files are saved with the input and output data of the solver. <code>delta_t</code> double Fixed time step size. This parameter is usually specified in a higher component. <code>input_file</code> str (optional) Name of the input file, which may be present in the folder given in <code>working_directory</code>. The file contains parameters required for the solver, in JSON-format. The parameters specified in the main parameter JSON file have priority over the parameters defined in this file. <code>interface_input</code> list List of dictionaries; each dictionary requires two keys: <code>model_part</code> and <code>variables</code>. The former contains the name of the <code>ModelPart</code> as a string. The value of the latter is a list of variables. Even if there is only one variable, a list is required. For the Python solver wrappers these variables are fixed: <code>['displacement']</code> for a flow solver and <code>['pressure','traction']</code> for a structural solver. <code>interface_output</code> list Analogous to <code>interface_input</code>. However, the variables are different: <code>['pressure','traction']</code> for a flow solver and <code>['displacement']</code> for a structural solver. <code>print_coupling_convergence</code> bool (optional) Default <code>false</code>. If <code>true</code> and if the solver coupling convergence is checked, a statement is printed when the solver converges in the first solver iteration, see solver coupling convergence. <code>unsteady</code> bool (optional) Default: <code>true</code>. Indicates if case is steady or unsteady. <code>save_restart</code> int (optional) Default: 0. Determines the time step interval upon which a pickle file <code>case_timestep&lt;time step&gt;.pickle</code> is written, to be used for restart purposes. A minus sign indicates only the file from the last interval is retained. <code>time_step_start</code> int (optional) Default: 0. Time step number to (re)start a transient FSI calculation. If <code>0</code> is given, the simulation starts from scratch. Otherwise, the code looks for the pickle file <code>case_timestep&lt;timestep_start&gt;.pickle</code> to start from the corresponding time step. For a steady simulation, the value should be <code>0</code>. <code>working_directory</code> str Absolute path to the working directory or relative path with respect to the current directory. <p><code>delta_t</code> is a necessary parameter, while <code>timestep_start</code> and <code>save_restart</code> are optional, but all are usually defined in a higher component. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher component and in the solver wrapper, then the former value is used and a warning is printed.</p> <p>Because these solvers are simple, it is possible to omit the use of interpolation between two solver wrappers. In that case, the names of the <code>ModelParts</code> of both flow and structural solver need to be the same.</p>"},{"location":"python.html#tube-flow-solver","title":"Tube flow solver","text":"<p>This flow solver calculates the flow inside a 1D straight and flexible tube. The <code>type</code> for this solver wrapper is <code>solver_wrappers.python.tube_flow_solver</code>. The required input is the radial displacement of the tube wall. The other components of displacement are ignored. The resulting output is the pressure on the tube wall. Although a required variable in <code>interface_output</code>, <code>traction</code> is always returned as being zero.</p> <p>From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 the cross-sectional area of the tube and r the inner radius. Furthermore, t is the time, v the velocity along the axis of the tube, p the pressure and \\rho_f the density of the fluid. At the start and at the end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid.</p> <p>The boundary conditions are implemented by four additional equations: at the in- and outlet for both pressure and velocity. At the inlet, the pressure, velocity or total pressure can be specified. At the outlet, the pressure can be set to a fixed value or a non-reflecting boundary conditions. These settings are specified in the <code>input_file</code> in the <code>working directory</code>.</p> <p>For more information about the implementation of this solver refer to [1].</p> <p>Finally, this solver also provides a Jacobian of the change in radius with pressure, which can be used as surrogate Jacobian [4].</p>"},{"location":"python.html#solver-parameters","title":"Solver parameters","text":"<p>The following parameters, listed in alphabetical order, need to be specified in the main JSON file or in a file with name <code>input_file</code>, located in the <code>working_directory</code>. Care should be taken that the values of <code>d</code>, <code>e</code>, <code>h</code>, <code>l</code> and <code>rhof</code> match the corresponding values of the structural solver.</p> parameter type description <code>axial_offset</code> double (optional) Default: <code>0</code>. Distance over which tube is displaced axially in the coordinate system. <code>d</code> double Nominal diameter of the tube. <code>e</code> double Modulus of elasticity of the tube wall. <code>h</code> double Thickness of the tube wall. <code>inlet_boundary</code> dict Dictionary containing all information with respect to the inlet boundary condition. <code>l</code> double Length of the tube. <code>m</code> int Number of cells for discretization. The values are calculated in the cell centers. <code>newtonmax</code> double Maximum number of Newton-Raphson iterations for the flow solver calculation. <code>newtontol</code> double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. <code>outlet_boundary</code> dict Dictionary containing all information with respect to the outlet boundary condition. <code>preference</code> double (optional) Default: <code>0</code>. Reference pressure and initial pressure. <code>u0</code> double (optional) Default: <code>ureference</code>. Initial velocity throughout the tube. <code>ureference</code> double Reference velocity used for determination of pressure stabilization term. <code>rhof</code> double Density of the fluid."},{"location":"python.html#inlet-boundary","title":"Inlet boundary","text":"<p>This section describes all parameters that need to be specified in the dictionary <code>inlet_boundary</code>, listed in alphabetical order.</p> parameter type description <code>amplitude</code> double Amplitude of the inlet boundary condition. <code>period</code> double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. Not used for a fixed value boundary condition (type <code>4</code>). <code>reference</code> double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. <code>ureference</code>, <code>preference</code> or <code>preference</code> + <code>rhof</code> * <code>ureference</code>^2 / 2. <code>type</code> int Type of inlet boundary condition. If <code>1</code>, a sine wave is used with amplitude, reference and period as specified. If <code>2</code>, a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If <code>3</code>, a quadratic sine wave is used with amplitude, reference and period as specified. If <code>4</code>, a fixed value equal to the sum of the reference value and the amplitude. Used for steady cases. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. <code>variable</code> str Variable upon which the inlet boundary condition is defined, either <code>'pressure'</code>, <code>'velocity'</code> or <code>'total pressure'</code>."},{"location":"python.html#outlet-boundary","title":"Outlet boundary","text":"<p>This section describes all parameters that need to be specified in the dictionary <code>outlet_boundary</code>, listed in alphabetical order.</p> parameter type description <code>type</code> int Type of outlet boundary condition. If <code>1</code>, a non-reflecting boundary condition is applied. This type cannot be used for a steady calculation. If other, a fixed value equal to the reference pressure is applied."},{"location":"python.html#tube-ringmodel-solver","title":"Tube ringmodel solver","text":"<p>This structural solver calculates the deformation of the wall of a straight and flexible tube. The <code>type</code> for this solver wrapper is <code>solver_wrappers.python.ring_model_solver</code>. The tube is regarded as made up of independent rings and no inertia is taken into account. Therefore, there is no dependence on previous time steps and the parameters <code>delta_t</code> and <code>timestep_start</code> are not used. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in <code>interface_input</code>.  The resulting output is the radial displacement. For the other components of displacement, zero is returned. This solver is not suited to calculate the propagation of a pressure pulse.</p> <p>The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 the cross-sectional area of the tube and r the inner radius. Furthermore, p the pressure, p_0 the reference pressure, \\rho_f the density of the fluid and c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E is the modulus of elasticity, h the thickness of the tube wall and r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid.</p> <p>More information about the implementation of this solver can be found in [2].</p>"},{"location":"python.html#solver-parameters_1","title":"Solver parameters","text":"<p>The following parameters, listed in alphabetical order, need to be specified in the main JSON file or in a file with name <code>input_file</code>, located in the <code>working_directory</code>. Care should be taken that the values of <code>d</code>, <code>e</code>, <code>h</code>, <code>l</code> and <code>rhof</code> match the corresponding values of the flow solver.</p> parameter type description <code>axial_offset</code> double (optional) Default: <code>0</code>. Distance over which tube is displaced axially in the coordinate system. <code>d</code> double Nominal diameter of the tube. <code>e</code> double Modulus of elasticity of the tube wall. <code>h</code> double Thickness of tube wall. <code>l</code> double Length of the tube. <code>m</code> int Number of cells for discretization. The values are calculated in the cell centers. <code>preference</code> double (optional) Default: <code>0</code>. Reference pressure. <code>residual_atol</code> double Absolute residual tolerance, only used and required for the solver coupling convergence criterion. <code>rhof</code> double Density of the fluid."},{"location":"python.html#tube-structural-solver","title":"Tube structural solver","text":"<p>This structural solver calculates the deformation of the wall of a straight and flexible tube. The <code>type</code> for this solver wrapper is <code>solver_wrappers.python.tube_structure_solver</code>. In this model inertia is taken into account, but still only radial displacement is considered. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in <code>interface_input</code>.  The resulting output is the radial displacement. For the other components of displacement, zero is returned.</p> <p>The deformation of the tube in the radial direction is determined by $$     \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s the solid density and h the thickness of the tube wall. Further, r is the inner radius, p pressure and t time. The variables r_0 and p_0 are a reference radius and pressure, respectively. The parameters b_1 and b_2 (b_1, b_2 \\ge 0) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$     b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}      \\textrm{, }     b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2}     \\textrm{ and }     b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E the Young's modulus and \\nu Poisson's coefficient. The second term of b_3 is considered small compared to the first one because h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations with a Jacobian that does not depend on the pressure, nor the radius. This system is solved for the radius without requiring iterations.</p> <p>There are two solving options available, specified with the parameter <code>solver</code>. The fastest and most memory efficient is the \"solve_banded\" option, which writes the matrix in a diagonal ordered form. In this way, memory use and the number of operations is reduced. However, when the number of discretization intervals increases, the condition number of the coefficient matrix quickly increases. For high condition number, the \"direct\" method is more accurate and allows deeper convergence. This option calculates the inverse of the coefficient matrix directly, at the start of the calculation. The inverse is only calculated once and thereafter stored. When the number of intervals is high, it is clear that this option will use a high amount of memory.</p> <p>The tube is considered clamped at both ends. This boundary condition is imposed by adding four equations: two at the inlet and two at the outlet.</p> <p>For more information about the implementation of this solver refer to [1]. In this work the Newmark-beta time discretization is used. Here, however, backward Euler time discretization is used as well.</p> <p>For the Newmark-beta time discretization, two Newmark parameters \\beta and \\gamma are required, which result in an unconditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2}  \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$ Typical values are \\gamma equal to 1/2 and \\beta equal to 1/4.</p> <p>A different time discretization for flow and structure can lead to difficulties for strongly coupled problems, especially looking at the resulting pressure distributions. As most flow solvers are discretized using the backward Euler method, it is advised to choose the same method for the structural solver (the time discretization of <code>SolverWrapperTubeFlowSolver</code> is also backward Euler). This avoids the occurrence of spurious oscillations of the pressure in time [3].</p> <p>Finally, this solver also provides a Jacobian of the change in radius with pressure, which can be used as surrogate Jacobian [4].</p>"},{"location":"python.html#solver-parameters_2","title":"Solver parameters","text":"<p>The following parameters, listed in alphabetical order, need to be specified in the main JSON file or in a file with name <code>input_file</code>, located in the <code>working_directory</code>. Care should be taken that the values of <code>d</code>, <code>e</code>, <code>h</code>, <code>l</code> and <code>rhof</code> match the corresponding values of the flow solver.</p> parameter type description <code>axial_offset</code> double (optional) Default: <code>0</code>. Distance over which tube is displaced axially in the coordinate system. <code>beta</code> double (optional) Newmark parameter \\beta. Only required when the Newmark-beta time discretization is used. <code>d</code> double Nominal diameter of the tube. <code>e</code> double Modulus of elasticity of the tube wall. <code>h</code> double Thickness of the tube wall. <code>gamma</code> double (optional) Newmark parameter \\gamma. Only required when the Newmark-beta time discretization is used. <code>l</code> double Length of the tube. <code>m</code> int Number of cells for discretization. The values are calculated in the cell centers. <code>nu</code> double Poisson's ratio. <code>preference</code> double (optional) Default: <code>0</code>. Reference pressure. <code>residual_atol</code> double Absolute residual tolerance, only used and required for the solver coupling convergence criterion. <code>rhof</code> double Density of the fluid. <code>rhos</code> double Density of the tube wall. <code>solver</code> str (optional) Default: <code>solve_banded</code>. Either <code>solve_banded</code> or <code>direct</code>. Specifies the solution method for the linear system of equations. <code>time_disretization</code> str (optional) Default: <code>backward Euler</code>. Specifies the time discretization: either <code>Newmark</code> or <code>backward Euler</code>. Not case sensitive."},{"location":"python.html#solver-coupling-convergence","title":"Solver coupling convergence","text":"<p>The convergence criterion solver coupling convergence has been implemented for the Tube Python solvers. The Tube Structure solver and the Tube Ringmodel solver are linear, meaning that no solver iterations are performed. As a consequence no convergence tolerance is prescribed for these solvers.</p> <p>However, when coupled with another solver, the initial residual (calculated with an updated right-hand side, but before the solution of their linear system) can still have a non-converged value. This is exactly the residual value that is used by the convergence criterion to determine if the coupling has converged. Therefore, a solver tolerance <code>residual_atol</code> has to be defined for these solvers in case the solver coupling convergence criterion is selected.</p>"},{"location":"python.html#references","title":"References","text":"<p>[1] Degroote J., Annerel S. and Vierendeels J., \"Stability analysis of Gauss-Seidel iterations in a partitioned simulation of fluid-structure interaction\", Computers &amp; Structures, vol. 88, no. 5-6, pp. 263, 2010.</p> <p>[2] Degroote J., Bruggeman P., Haelterman R. and Vierendeels J., \"Stability of a coupling technique for partitioned solvers in FSI applications\", Computers &amp; Structures, vol. 86, no. 23\u201324, pp. 2224\u20132234, 2008.</p> <p>[3] Vierendeels J., Dumont K., Dick E. and Verdonck P., \"Analysis and stabilization of fluid-structure interaction algorithm for rigid-body motion\", American Institute of Aeronautics and Astronautics Journal\", vol. 43, no. 12, pp. 2549\u20132557, 2005.</p> <p>[4] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Surrogate-based acceleration of quasi-Newton techniques for fluid-structure interaction simulations\", Computers &amp; Structures, vol. 260, pp. 106720, 2022.</p>"},{"location":"solver_wrappers.html","title":"Solver wrappers","text":"<p>The goal of solver wrappers is to provide communication with the solvers. This means that a solver wrapper must implement a way to communicate input to the solver (at the fluid-structure interface), run the solver with the provided input and obtain the solution from the solver (at the fluid-structure interface).</p> <p>Important: To avoid conflicts, each solver is run in its own environment. These environments are established on runtime, but the actions required to do so can differ between systems. Therefore, it is necessary to first check (and if needed adapt) the file <code>coconut/solver_modules.py</code> after installing or updating CoCoNuT, as described in the front documentation page.</p> <p>As each solver is different, the solver wrappers are highly customized too. Nevertheless, they all inherit from the <code>SolverWrapper</code> class, which inherits from the <code>Component</code> class, and must all implement the following methods: <code>initialize</code>, <code>initialize_solution_step</code>, <code>solve_solution_step</code>, <code>finalize_solution_step</code>,  <code>output_solution_step</code> and <code>finalize</code>.</p> <p>Upon instantiation of the solver wrapper object, the solver wrapper has to create a <code>Model</code> containing one or more <code>ModelParts</code> which correspond to (a part of) the fluid-structure interface. The interface coordinates at time step 0 should be stored in the <code>ModelPart</code>, even for a simulation that is restarted from a later time step, in order to have consistent mapping over restarts.</p> <p>The <code>solve_solution_step</code> method is called in each coupling iteration by the coupled solver, which provides input data stored in an <code>Interface</code> object. The solver wrapper extracts the data and supplies it to the actual solver, starts the calculation and reads the output data when the solver has finished. The solver wrapper then returns this data to the coupled solver as an <code>Interface</code> object.</p>"},{"location":"solver_wrappers.html#available-solver-wrappers","title":"Available solver wrappers","text":"<p>There are currently two solver wrappers for computational fluid dynamics (CFD) packages:</p> <ul> <li>ANSYS Fluent (2019R3, 2021R1, 2023R1)</li> <li>OpenFOAM (8)</li> </ul> <p>There are currently also two solver wrappers for computational structural mechanics (CSM) packages :</p> <ul> <li>Abaqus (2021, 2022)</li> <li>Kratos Multiphysics (9.1)</li> </ul> <p>CoCoNuT also implements several 1D Python-based solver wrappers to provide a fast and easy way to test new algorithms and implementations. These are:</p> <ul> <li>Tube flow solver</li> <li>Tube structure solver</li> <li>Tube ringmodel solver</li> </ul>"},{"location":"test_single_solver.html","title":"Example case to test individual solvers","text":"<p>This example shows how the separate solvers or their cases in the respective working directories can be tested individually using <code>test_single_solver</code> as coupling component. For more information refer to coupled_solvers.</p>"},{"location":"test_single_solver.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The <code>type</code> is set to <code>coupled_solvers.test_single_solver</code> and an additional required dictionary <code>test_settings</code> is added. All other parameters in the JSON file, including the <code>settings</code> dictionary, can be set to the values that will be used in the actual coupled simulation. The <code>settings</code> dictionary is used to look up <code>delta_t</code>, <code>timestep_start</code>, <code>save_results</code> and <code>name</code> if not provided in <code>test_settings</code>. The other dictionaries are not used: no <code>predictor</code>,<code>convergence_criterion</code> or <code>mapper</code> are used.</p>"},{"location":"test_single_solver.html#solvers","title":"Solvers","text":"<p>If you run this case as is, the Fluent case and solver will be tested, as the <code>solver_index</code> is set to 0 in <code>test_settings</code>. In that case the Abaqus settings won't be used. The Abaqus case can easily be tested by changing this value to 1, then the Fluent settings will not be used. The index refers to the index of the respective solver in the <code>solver_wrappers</code> list in the JSON file.</p>"},{"location":"test_single_solver.html#dummy-solver","title":"Dummy solver","text":"<p>Even though the presence of <code>dummy_solver.py</code> with a test class is not strictly required, it can be very valuable because it allows to have a non-zero input. The file included in this case provides an example. It contains, among others, <code>SimpleTest</code>, <code>TransientTest</code> and <code>InterpolatedData</code> to illustrate how variables can be defined based on undeformed coordinates (<code>x</code>, <code>y</code>, <code>z</code>) and time step (<code>n</code>). Note that the number of classes defined is not restricted. Also note that the <code>__init__()</code> method can be used to avoid repeating the same calculations multiple times. The name of the class that one wants to use should be specified in the JSON file.  In this example the <code>TransientTest</code> is used. Each class contains function definitions with a pre-formatted name <code>calculate_&lt;variable&gt;(x,y,z,n)</code>, with <code>&lt;variable&gt;</code> being the variable(s) required by the tested solver, e.g. <code>displacement</code>, <code>pressure</code> or <code>traction</code>. How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.</p>"},{"location":"tests.html","title":"Tests","text":""},{"location":"tests.html#idea","title":"Idea","text":"<p>Unit tests are particularly important to developers to debug their code separately from other coupling components. These  unit tests also offer an opportunity to quickly check whether the installation of the package was successful, as mentioned  on the start page. </p> <p>The remainder of this documentation page focuses on running these tests. The first section explains the procedure to run (almost) all tests at once, which is useful for the post-installation test. The second section contains information on how to  include the unit test of a solver wrapper in the testing framework. Finally, it is explained how to run a single test file, test class or test method. The latter is useful in the development of a new solver wrappers to quickly test a single  aspect of the wrapper without having to test all aspects together, which can be time-consuming. </p>"},{"location":"tests.html#running-unit-tests","title":"Running unit tests","text":""},{"location":"tests.html#running-unit-tests_1","title":"Running unit tests","text":"<p>The unit tests in CoCoNuT uses the unittest module available in Python.  To run the default collection of tests which evaluates in a matter of seconds, navigate to the <code>coconut/tests/</code> directory  and type following command in the terminal: <pre><code>python3 run_tests.py\n</code></pre> This command will run all tests excluding the solver wrapper tests that are not pure Python. These tests are excluded because they each take several minutes to complete. The above command is equivalent to  <pre><code>python3 run_tests.py -fast\n</code></pre> It is equally possible to run all test by using the keyword <code>-all</code> as follows <pre><code>python3 run_tests.py -all\n</code></pre> Besides these two predefined keywords, it is also possible to use (a set of) arbitrary keywords. For example <pre><code>python3 run_tests.py fluent abaqus\n</code></pre> will run all tests that have the <code>fluent</code> or <code>abaqus</code> in its path: for example <code>coconut.tests.solver_wrappers.fluent.test_v2023R1.test_move_nodes</code>.</p> <p>Starting from Anaconda 2023.09, to run a specific test, it is sufficient to provide the full path, for example <pre><code>python3 run_tests.py solver_wrappers.fluent.test_v2023R1.TestSolverWrapperFluent2023R1Tube3D.test_partitioning\n</code></pre> Here, only the test method <code>test_partitioning</code> is run in the <code>TestSolverWrapperFluent2023R1Tube3D</code> class. Similarly, to run all methods in a particular class, it is sufficient to include the path up to the class name (or simply the class name itself, if there exists no duplicate).</p> <p>Besides the method of running tests explained above, it is also possible to use commands of the form <pre><code>python3 -m unittest -bv\n</code></pre> Here, the keyword <code>discover</code> is assumed silently and all unit tests in modules named <code>test*.py</code> will be looked for. It will recursively find all the test files with this pattern for all the folders containing an <code>__init__.py</code>_ file.  The <code>-b</code> keyword suppresses any output generated by the part of the code that is being tested, unless an error occurs or a test fails.  Finally, the <code>-v</code> keyword enables a higher verbosity, as such the user can see what test methods have been run. Further documentation  on the Python unit test framework can be found on the Python documentation website.</p> <p>To run a specific test for earlier Python versions, it is required to use <pre><code>python3 -m unittest -bv solver_wrappers.fluent.test_v2023R1.TestSolverWrapperFluent2023R1Tube3D.test_partitioning\n</code></pre></p>"},{"location":"tests.html#what-if-solver-software-is-not-available","title":"What if solver software is not available","text":"<p>If a solver wrapper test is run, but the software is not available, the test will automatically be skipped and the non-availability wil be given as the reason. The availability of software is checked using the <code>solver_modules.py</code> file.</p>"},{"location":"tube_fluent2d_abaqus2d.html","title":"Tube case with Fluent2D and Abaqus2D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case.</p>"},{"location":"tube_fluent2d_abaqus2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_fluent2d_abaqus2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_fluent2d_abaqus2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 10.</li> <li>The residual norm on the displacement is a factor 10^{-4} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_fluent2d_abaqus2d.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface.  When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes, of which there are 101.  In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis.  The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube2d.msh</code>. This case is written to the <code>case_tube2d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube2d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube2d.inp</code>. The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist.  They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information.  The loads are applied on the faces in three points per element, which means on 150 load points in total.  The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis.</p> <p>The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structural solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.</p>"},{"location":"tube_fluent2d_abaqus2d_steady.html","title":"Tube case with Fluent2D and Abaqus2D - Steady","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, when a steady pressure difference is applied over the tube. This done by using Fluent and Abaqus, both on an axisymmetric case.</p> <p>The test example is similar in setup to <code>tube_fluent2d_abaqus2d</code>. The only difference is that a steady problem is simulated. Here the most important differences and peculiarities of a steady case are highlighted.</p>"},{"location":"tube_fluent2d_abaqus2d_steady.html#general-settings","title":"General settings","text":"<p>Although the calculation is steady, a <code>delta_t</code> is still required. Its value is arbitrary and usually 1.0 is used. <code>timestep_start</code> is required as well and is normally equal to 0.</p>"},{"location":"tube_fluent2d_abaqus2d_steady.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). The parameter <code>q</code> is not used as there is only one time step. Note that in a steady calculation, the models <code>ls</code> (IQN-ILS) and <code>mv</code> (IQN-MVJ) are identical.</p>"},{"location":"tube_fluent2d_abaqus2d_steady.html#predictor","title":"Predictor","text":"<p>A predictor is still required, but not used as only one time step is calculated.</p>"},{"location":"tube_fluent2d_abaqus2d_steady.html#solvers","title":"Solvers","text":"<p>Of course the supplied case files in both Fluent and Abaqus also need to be steady.  In Abaqus this can be done using a Static step, typically with automatic time incrementation (subcycling) and a linearly ramped load. The parameter <code>ramp</code> is set to <code>true</code> in the json-file. As such Abaqus performs subiterations in each coupling iterations in which the load is increased linearly over the step. The ramping does not occur in Abaqus itself as, amplitude references are ignored for nonuniform loads given by user subroutine DLOAD in an Abaqus/Standard analysis. Instead, the ramping is implemented in the DLOAD subroutine itself. For the first iteration of the first time step an initial load is required which is set to zero in the Abaqus wrapper.</p>"},{"location":"tube_fluent2d_abaqus2d_surrogate.html","title":"Tube case with TubeFlow and TubeStructure and Surrogate model","text":"<p>This example is identical to the example Fluent2D and Abaqus2D, except for the use of a surrogate model. This is reflected in a different coupled solver and corresponding models, and the type of predictor. The used surrogate model is the combination of the 1D Python solvers TubeFlow and TubeStructure.</p>"},{"location":"tube_fluent2d_abaqus2d_surrogate.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupled solver used is <code>coupled_solvers.iqnism</code>, which has a <code>model</code> and <code>surrogate</code> setting, both of which are a type of model component. The secant model used is <code>coupled_solvers.models.mvmf</code> where 100 time steps are reused: the previous time steps are used as surrogate model. In addition, a <code>surrogate</code> model is defined, which uses the 1D Python solvers TubeFlow and TubeStructure. Because of this different discretization, mapping is required. This is achieved using the <code>mapped</code> model. The <code>surrogate</code> model has its own coupled solver with its own predictor, convergence criterion, solver wrappers and models. The model is once more <code>coupled_solvers.models.mvmf</code> that reuses 100 time steps as surrogate model. Note that the surrogate solvers have their own working directory.</p> <p>The <code>settings</code> of <code>coupled_solvers.iqnism</code> dictate that <code>surrogate_synchronize</code> is enabled. This means that at the end of each time step, the surrogate solvers are solved once more with final solution of the actual solvers, such that they are synchronized. This is also shown in the printing of the residuals.</p> <p>Note that the relaxation factor \\omega is omitted in <code>coupled_solvers.iqnism</code>, such that its default value, equal to 1, is used. This is possible because the surrogate model provides a Jacobian, when the secant model is not yet able to. The coupled solver <code>coupled_solvers.iqni</code> inside of the <code>surrogate</code> does require a relaxation factor.</p>"},{"location":"tube_fluent2d_abaqus2d_surrogate.html#predictor","title":"Predictor","text":"<p>The predictor of the <code>coupled_solvers.iqnism</code> is <code>predictors.surrogate</code>, which means the surrogate solution is used for the prediction of the actual solver. As the <code>predict_change</code> is not disabled, it is the change in surrogate solution with respect to the previous time step that will be used to determine the prediction for the current time step starting from the previous one.</p>"},{"location":"tube_fluent2d_abaqus2d_surrogate.html#mappers","title":"Mappers","text":"<p>Mappers are used in three locations:</p> <ul> <li>To map the input and output of the actual solvers</li> <li>To map the input and output of the surrogate solvers</li> <li>To map the discretization of the surrogate and actual solvers</li> </ul> <p>Here, <code>mappers.linear</code> are used each time.</p>"},{"location":"tube_fluent2d_abaqus2d_surrogate.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface.  When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes, of which there are 101.  In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis.  The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube2d.msh</code>. This case is written to the <code>case_tube2d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube2d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube2d.inp</code>. The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist.  They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information.  The loads are applied on the faces in three points per element, which means on 150 load points in total.  The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis.</p> <p>The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structural solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.</p>"},{"location":"tube_fluent2d_tube_structure.html","title":"Tube case with Fluent2D and TubeStructure","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure.</p>"},{"location":"tube_fluent2d_tube_structure.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_fluent2d_tube_structure.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_fluent2d_tube_structure.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm on the displacement is a factor 10^{-6} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_fluent2d_tube_structure.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface.  When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes, of which there are 101.  In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube2d.msh</code>. This case is written to the <code>case_tube2d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file <code>solver_parameters.json</code>. The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structural solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.</p>"},{"location":"tube_fluent3d_abaqus2d.html","title":"Tube case with Fluent3D and Abaqus2D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case).</p>"},{"location":"tube_fluent3d_abaqus2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_fluent3d_abaqus2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_fluent3d_abaqus2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_fluent3d_abaqus2d.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube3d.msh</code>. This case is written to the <code>case_tube3d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube2d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube2d.inp</code>. The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist.  They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information.  The loads are applied on the faces in three points per element, which means on 150 load points in total.  The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis.</p> <p>The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structural solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally, a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.</p>"},{"location":"tube_fluent3d_abaqus3d.html","title":"Tube case with Fluent3D and Abaqus3D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case.</p>"},{"location":"tube_fluent3d_abaqus3d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_fluent3d_abaqus3d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_fluent3d_abaqus3d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_fluent3d_abaqus3d.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube3d.msh</code>. This case is written to the <code>case_tube3d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube3d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube3d.inp</code>. The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information.  The loads are applied on the faces in 9 points per element, which means on 864 load points in total.  The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structural solver to interpolate in the x-, y- and z-direction.</p>"},{"location":"tube_fluent3d_kratos_structure3d.html","title":"Tube case with Fluent3D and KratosStructure3D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and StructuralMechanicsApplication of Kratos, both with a fully 3D case.</p>"},{"location":"tube_fluent3d_kratos_structure3d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_fluent3d_kratos_structure3d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_fluent3d_kratos_structure3d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_fluent3d_kratos_structure3d.html#solvers","title":"Solvers","text":"<p>The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file <code>mesh.jou</code> using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the <code>case.jou</code> journal file to set up the case parameters, starting from the mesh file <code>mesh_tube3d.msh</code>. This case is written to the <code>case_tube3d.cas</code> file, which serves as input for CoCoNuT.  Additionally, a folder <code>create_mesh</code> is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script <code>create_mesh.sh</code>, given that Gambit v2.4.6 is available.</p> <p>The structural solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length direction and 8 in the circumferential direction.  The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file <code>ProjectParameters.json</code> is passed to CoCoNuT.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.</p>"},{"location":"tube_openfoam3d_abaqus3d.html","title":"Tube case with OpenFOAM3D and Abaqus3D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and Abaqus, both with a fully 3D case.</p>"},{"location":"tube_openfoam3d_abaqus3d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_openfoam3d_abaqus3d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_openfoam3d_abaqus3d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_openfoam3d_abaqus3d.html#solvers","title":"Solvers","text":"<p>The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file <code>blockMeshDict</code>. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When setting up the case using the <code>setup.sh</code> script, the solver <code>coconut_pimpleFoam</code> is compiled automatically.</p> <p>The structural solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube3d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube3d.inp</code>. The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total.  The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structural solver to interpolate in the x-, y- and z-direction.</p>"},{"location":"tube_openfoam3d_kratos_structure3d.html","title":"Tube case with OpenFOAM3D and KratosStructure3D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and StructuralMechanicsApplication of Kratos, both with a fully 3D case.</p>"},{"location":"tube_openfoam3d_kratos_structure3d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_openfoam3d_kratos_structure3d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_openfoam3d_kratos_structure3d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 20.</li> <li>The residual norm on the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_openfoam3d_kratos_structure3d.html#solvers","title":"Solvers","text":"<p>The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file <code>blockMeshDict</code>. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When starting the simulation, the solver <code>coconut_pimpleFoam</code> is compiled automatically, if required.</p> <p>The structural solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length direction and 8 in the circumferential direction.  The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file <code>ProjectParameters.json</code> is passed to CoCoNuT.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.</p>"},{"location":"tube_tube_flow_abaqus2d.html","title":"Tube case with TubeFlow and Abaqus2D","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric).</p>"},{"location":"tube_tube_flow_abaqus2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_tube_flow_abaqus2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_tube_flow_abaqus2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm on the displacement is a factor 10^{-6} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_tube_flow_abaqus2d.html#solvers","title":"Solvers","text":"<p>The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface.  The parameters for this model are specified in the setup folder by the file <code>solver_parameters_pressure.json</code>. The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The structural solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file <code>mesh_tube2d.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_tube2d.inp</code>.The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist.  They are: 8-node biquadratic, reduced integration, hybrid with linear pressure.  See the Abaqus documentation for more information.  The loads are applied on the faces in three points per element, which means on 150 load points in total.  The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis.</p> <p>The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structural solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incoming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.</p>"},{"location":"tube_tube_flow_tube_ringmodel.html","title":"Tube case with TubeFlow and TubeRingmodel","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel.</p>"},{"location":"tube_tube_flow_tube_ringmodel.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS).</p>"},{"location":"tube_tube_flow_tube_ringmodel.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_tube_flow_tube_ringmodel.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm on the displacement is a factor 10^{-6} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_tube_flow_tube_ringmodel.html#solvers","title":"Solvers","text":"<p>The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface.  The parameters for this model are specified in the setup folder by the file <code>solver_parameters_velocity.json</code>. The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The structural solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file <code>solver_parameters.json</code>. The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. However, the discretization of both solvers differ. To account for the difference of the points where loads and displacements are applied or calculated, the use of interpolation mappers is required. Therefore, a linear interpolation mapper is introduced in the structural solver to interpolate in the x-direction.</p> <p>Additionally, a parameter file <code>parameters_conformal.json</code> is also provided. This parameter file performs no interpolation. It should be verified that the number of cells <code>m</code> is the same in both solvers before using it and is merely provided as a theoretical example as it will have close to no practical use. To run the example case with <code>parameters_conformal.json</code> as parameter file, the variable <code>parameter_file_name</code> should be adapted in the <code>run_simulation.py</code> script after setting up the case.</p>"},{"location":"tube_tube_flow_tube_structure.html","title":"Tube case with TubeFlow and TubeStructure","text":"<p>This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure.</p>"},{"location":"tube_tube_flow_tube_structure.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is IQN-ILSM with reuse of q = 100 time steps.</p>"},{"location":"tube_tube_flow_tube_structure.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the linear predictor.</p>"},{"location":"tube_tube_flow_tube_structure.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm on the displacement is a factor 10^{-6} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"tube_tube_flow_tube_structure.html#solvers","title":"Solvers","text":"<p>The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface.  The parameters for this model are specified in the setup folder by the file <code>solver_parameters_pressure.json</code>. The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The structural solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file <code>solver_parameters.json</code>. The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis.</p> <p>The coordinate frames of both solvers are the same so there is no need for a permutation mapper. Moreover, as both solvers have 100 cells on the fluid-structure interface, no interpolation is required. Nonetheless, a linear interpolation mapper for the structural solver to interpolate in the x-direction is included in the parameter file.  As such, the number of cells <code>m</code> can be varied independently in both solvers.</p>"},{"location":"tube_tube_flow_tube_structure_analytical.html","title":"Tube case with TubeFlow and TubeStructure and with Analytical1D model","text":"<p>This example is identical to Python TubeFlow - Python TubeStructure, with the only difference that a different model is used.</p>"},{"location":"tube_tube_flow_tube_structure_analytical.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupled solver used is <code>coupled_solvers.iqni</code>, just as in the example Python TubeFlow - Python TubeStructure. Only, now, the model is not <code>coupled_solvers.models.ls</code>, but <code>coupled_solvers.models.analytical_1d</code>, which uses two solver models (that should be the same as the actual solvers) to calculate an analytical Jacobian.</p> <p>Note that the relaxation factor omega may be equal to 1, as the analytical model is ready from the start, in contradiction to a secant model, which needs to collect input-output-pairs first.</p>"},{"location":"tube_tube_flow_tube_structure_surrogate.html","title":"Tube case with TubeFlow and TubeStructure and with Surrogate model","text":"<p>This example is identical to Python TubeFlow - Python TubeStructure, except for the use of a surrogate model. This is reflected in a different coupled solver and corresponding models, and the type of predictor.</p>"},{"location":"tube_tube_flow_tube_structure_surrogate.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupled solver used is <code>coupled_solvers.iqnism</code>, which has a <code>model</code> and <code>surrogate</code> setting, both of which are a type of model component. The secant model used is <code>coupled_solvers.models.mvmf</code> where 100 time steps are reused: the previous time steps are used as surrogate model. In addition, a <code>surrogate</code> model is defined, which uses similar solvers, but with <code>50</code> degrees of freedom (<code>m</code>), instead of <code>100</code>. Note, that the settings in the JSON file for these solvers overwrite the setting given in the <code>input_file</code>. Because of this different discretization, mapping is required. This is achieved using the <code>mapped</code> model. The <code>surrogate</code> model has its own coupled solver with its own predictor, convergence criterion, solver wrappers and models. The model is once more <code>coupled_solvers.models.mvmf</code> that reuses 100 time steps as surrogate model. Note that the surrogate solvers have their own working directory.</p> <p>The <code>settings</code> of <code>coupled_solvers.iqnism</code> dictate that <code>surrogate_synchronize</code> is enabled. This means that at the end of each time step, the surrogate solvers are solved once more with final solution of the actual solvers, such that they are synchronized. This is also shown in the printing of the residuals.</p> <p>Note that the relaxation factor \\omega is omitted in <code>coupled_solvers.iqnism</code>, such that its default value, equal to 1, is used. This is possible because the surrogate model provides a Jacobian, when the secant model is not yet able to. The coupled solver <code>coupled_solvers.iqni</code> inside of the <code>surrogate</code> does require a relaxation factor.</p>"},{"location":"tube_tube_flow_tube_structure_surrogate.html#predictor","title":"Predictor","text":"<p>The predictor of the <code>coupled_solvers.iqnism</code> is <code>predictors.surrogate</code>, which means the surrogate solution is used for the prediction of the actual solver. As the <code>predict_change</code> is not disabled, it is the change in surrogate solution with respect to the previous time step that will be used to determine the prediction for the current time step starting from the previous one.</p>"},{"location":"tube_tube_flow_tube_structure_surrogate.html#mappers","title":"Mappers","text":"<p>Mappers are used in three locations:</p> <ul> <li>To map the input and output of the actual solvers</li> <li>To map the input and output of the surrogate solvers</li> <li>To map the discretization of the surrogate and actual solvers</li> </ul> <p>Here, <code>mappers.linear</code> are used each time.</p>"},{"location":"turek_fluent2d_abaqus2d.html","title":"Turek benchmark with Fluent2D and Abaqus2D","text":"<p>This example calculates the well-known Turek benchmark, which consist of laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI2 setup, as detailed by Turek and Hron [1]. The challenging aspect of this benchmark lies in the large self-induced oscillation of the flag. The used solvers are Fluent and Abaqus. A script <code>evaluate_benchmark.py</code> is provided to compare the results with the benchmark results in [1]. Furthermore, the script <code>animate_beam.py</code> can be used to visualize the interface data throughout the calculation.</p> <p>Due to the time required for the oscillations to enter a periodic regime, this test case takes a long time to run.</p> <p>The figure below shows the resulting velocity contour plot (with Fluent). </p> <p>In the FSI2 set up a parabolic velocity profile is subscribed at the inlet with an average velocity of 1 m/s, ramped up slowly in time. The fluid parameters are: </p> <ul> <li>density: 1000 kg/m\u00b3</li> <li>dynamic viscosity: 1 Pa\\cdots</li> </ul> <p>The flag is consist of a linear elastic material with the following properties:</p> <ul> <li>density: 10^4 kg/m\u00b3</li> <li>modulus of elasticity: 1.4 10^6 Pa</li> <li>poisson's ratio: 0.4</li> </ul> <p>The total simulated time is 35 s in time steps of 0.002 s.</p>"},{"location":"turek_fluent2d_abaqus2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). The reuse parameter <code>q</code> is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence.</p>"},{"location":"turek_fluent2d_abaqus2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is done using the quadratic predictor.</p>"},{"location":"turek_fluent2d_abaqus2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm of the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"turek_fluent2d_abaqus2d.html#solvers","title":"Solvers","text":"<p>Fluent is used as flow solver. The provided mesh is triangular. When the gate bends re-meshing is performed to preserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters.</p> <p>The structural solver is Abaqus. The Abaqus case is built when setting up the case starting from the file <code>mesh_turek.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_turek.inp</code>. The Abaqus element type used is CPE8R.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.</p>"},{"location":"turek_fluent2d_abaqus2d.html#references","title":"References","text":"<p>[1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html","title":"Turek benchmark with Fluent2D and Abaqus2D - Steady","text":"<p>This example calculates the well-known Turek benchmark, which consist of laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI1 setup, as detailed by Turek and Hron [1]. This is a steady simulation. The used solvers are Fluent and Abaqus. A script <code>evaluate_benchmark.py</code> is provided to compare the results with the benchmark results in [1].</p> <p>The figure below shows the resulting velocity contour plot (with Fluent). </p> <p>In the FSI1 set up a parabolic velocity profile is subscribed at the inlet with an average velocity of 0.2 m/s. The flow is initialized with a velocity in the x-direction equal to 0.2 m/s. The fluid parameters are:</p> <ul> <li>density: 1000 kg/m\u00b3</li> <li>dynamic viscosity: 1 Pa\\cdots</li> </ul> <p>The flag is consist of a linear elastic material with the following properties:</p> <ul> <li>density: 1000 kg/m\u00b3</li> <li>modulus of elasticity: 1.4 10^6 Pa</li> <li>poisson's ratio: 0.4</li> </ul>"},{"location":"turek_fluent2d_abaqus2d_steady.html#general-setting","title":"General setting","text":"<p>Although the calculation is steady, a <code>delta_t</code> is still required. Its value is arbitrary and 0 is used. <code>timestep_start</code> is required as well and is set to 0. The <code>number_of_timesteps</code> is set to 1.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILS). Note that the reuse parameter <code>q</code> is not used as only one time step is calculated.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html#predictor","title":"Predictor","text":"<p>A predictor is still required, but not used as only one time step is calculated.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html#convergence-criterion","title":"Convergence criterion","text":"<p>Two convergence criteria have been specified:</p> <ul> <li>The number of iterations in every time step is larger than 15.</li> <li>The residual norm of the displacement is a factor 10^{-3} lower than the initial value.</li> </ul> <p>When either criterion is satisfied the simulation stops.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html#solvers","title":"Solvers","text":"<p>Fluent is used as flow solver. The provided mesh is triangular. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters.</p> <p>The structural solver is Abaqus. The Abaqus case is built when setting up the case starting from the file <code>mesh_turek.inp</code> containing nodes and elements.  This is done by running Abaqus with the <code>make_inp.py</code> Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file <code>case_turek.inp</code>. The Abaqus element type used is CPE8R.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.</p>"},{"location":"turek_fluent2d_abaqus2d_steady.html#references","title":"References","text":"<p>[1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.</p>"},{"location":"turek_openfoam2d_kratos_structure2d.html","title":"Turek benchmark with OpenFOAM2D and KratosStructure2D","text":"<p>This example calculates the well-known Turek benchmark, which consist of laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI2 setup, as detailed by Turek and Hron [1]. The challenging aspect of this benchmark lies in the large self-induced oscillation of the flag. The used solvers are OpenFOAM and Kratos Multiphysics Structural Mechanics application. Furthermore, the script <code>animate_beam.py</code> can be used to visualize the interface data throughout the calculation. A video made with ParaView is shown below.</p> <p>With these solvers, the run time is significantly smaller than that of the same test case with Fluent and Abaqus. For details on boundary conditions and parameters refer to the example with Fluent and Abaqus.</p> <p>The accuracy of the simulation framework can be assessed by comparing with the results in Turek and Hron [1]. A script <code>evaluate_benchmark.py</code> is provided to extract the necessary quantities, which are given below using the format \"mean value +/- amplitude [frequency]\".</p> x displacement y displacement CoCoNuT with OpenFOAM and Kratos -1.463e-02 +/-1.225e-02 [3.9] 1.250e-03 +/-8.061e-02 [1.9] Benchmark -1.458e-02 +/-1.244e-02 [3.8] 1.230e-03 +/-8.060e-02 [2.0] drag lift CoCoNuT with OpenFOAM and Kratos 2.149e+02 +/-7.491e+01 [3.9] -5.939e-01 +/-2.370e+02 [1.9] Benchmark 2.0883e+02 +/-7.375e+01 [3.8] 8.800e-01 +/-2.342e+02 [2.0]"},{"location":"turek_openfoam2d_kratos_structure2d.html#coupling-algorithm","title":"Coupling algorithm","text":"<p>The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQN-ILSM). The reuse parameter <code>q</code> is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence.</p>"},{"location":"turek_openfoam2d_kratos_structure2d.html#predictor","title":"Predictor","text":"<p>The initial guess in every time step is made using the quadratic predictor.</p>"},{"location":"turek_openfoam2d_kratos_structure2d.html#convergence-criterion","title":"Convergence criterion","text":"<p>The time step is considered converged when the solver coupling convergence criterion is satisfied for both solvers. This criterion checks whether the solver residual is below the solver tolerance at the start of the solver call (or after one iteration for OpenFOAM).</p>"},{"location":"turek_openfoam2d_kratos_structure2d.html#solvers","title":"Solvers","text":"<p>OpenFOAM is used as flow solver. The provided mesh is quadrilateral. Some finer mesh settings are provided in the blockMeshDict.</p> <p>The structural solver is Kratos Multiphysics. First-order, quadrilateral, plane strain elements are used.</p> <p>To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structural solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.</p>"},{"location":"turek_openfoam2d_kratos_structure2d.html#references","title":"References","text":"<p>[1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.</p>"}]}